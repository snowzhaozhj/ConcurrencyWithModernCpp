<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>使用CppMem进行优化 - ConcurrencyWithModernCpp</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../../favicon.svg">
                        <link rel="shortcut icon" href="../../../favicon.png">
                <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
                <link rel="stylesheet" href="../../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../content/Reader-Testimonials.html"><strong aria-hidden="true">1.</strong> 读者推荐</a></li><li class="chapter-item expanded "><a href="../../../content/Source-Code.html"><strong aria-hidden="true">2.</strong> 代码说明</a></li><li class="chapter-item expanded "><a href="../../../content/How-you-should-read-the-book.html"><strong aria-hidden="true">3.</strong> 如何阅读</a></li><li class="chapter-item expanded "><a href="../../../content/History-Quick-Overview.html"><strong aria-hidden="true">4.</strong> C++并发历史概述</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 详细介绍</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.0-chinese.html"><strong aria-hidden="true">5.1.</strong> 内存模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.1-chinese.html"><strong aria-hidden="true">5.1.1.</strong> 内存模型的基础知识</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.2-chinese.html"><strong aria-hidden="true">5.1.2.</strong> 编程协议</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.3-chinese.html"><strong aria-hidden="true">5.1.3.</strong> 原子操作</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.4-chinese.html"><strong aria-hidden="true">5.1.4.</strong> 同步和顺序</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.5-chinese.html"><strong aria-hidden="true">5.1.5.</strong> 栅栏(Fences)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.0-chinese.html"><strong aria-hidden="true">5.2.</strong> 多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.1-chinese.html"><strong aria-hidden="true">5.2.1.</strong> 线程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.2-chinese.html"><strong aria-hidden="true">5.2.2.</strong> 共享数据</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.3-chinese.html"><strong aria-hidden="true">5.2.3.</strong> 线程-本地数据</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.4-chinese.html"><strong aria-hidden="true">5.2.4.</strong> 条件变量</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.5-chinese.html"><strong aria-hidden="true">5.2.5.</strong> 任务</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.0-chinese.html"><strong aria-hidden="true">5.3.</strong> 标准库的并行算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.1-chinese.html"><strong aria-hidden="true">5.3.1.</strong> 执行策略</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.2-chinese.html"><strong aria-hidden="true">5.3.2.</strong> 算法</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.3-chinese.html"><strong aria-hidden="true">5.3.3.</strong> 新算法</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.4-chinese.html"><strong aria-hidden="true">5.3.4.</strong> 性能概况</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.0-chinese.html"><strong aria-hidden="true">5.4.</strong> 案例研究</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.1-chinese.html"><strong aria-hidden="true">5.4.1.</strong> 求向量元素的加和</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.2-chinese.html"><strong aria-hidden="true">5.4.2.</strong> 单例模式：线程安全的初始化</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.3-chinese.html" class="active"><strong aria-hidden="true">5.4.3.</strong> 使用CppMem进行优化</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.4-chinese.html"><strong aria-hidden="true">5.4.4.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.0-chinese.html"><strong aria-hidden="true">5.5.</strong> C++20/23的特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.1-chinese.html"><strong aria-hidden="true">5.5.1.</strong> 关于执行</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.2-chinese.html"><strong aria-hidden="true">5.5.2.</strong> 可协作中断的线程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.3-chinese.html"><strong aria-hidden="true">5.5.3.</strong> 原子智能指针</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.4-chinese.html"><strong aria-hidden="true">5.5.4.</strong> 扩展特性</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.5-chinese.html"><strong aria-hidden="true">5.5.5.</strong> 门闩和栅栏</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.6-chinese.html"><strong aria-hidden="true">5.5.6.</strong> 协程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.7-chinese.html"><strong aria-hidden="true">5.5.7.</strong> 事务性内存</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.8-chinese.html"><strong aria-hidden="true">5.5.8.</strong> 任务块</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.0-chinese.html"><strong aria-hidden="true">6.1.</strong> 模式和最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.1-chinese.html"><strong aria-hidden="true">6.1.1.</strong> 相关历史</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.2-chinese.html"><strong aria-hidden="true">6.1.2.</strong> 价值所在</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.3-chinese.html"><strong aria-hidden="true">6.1.3.</strong> 模式与最佳实践</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.4-chinese.html"><strong aria-hidden="true">6.1.4.</strong> 反模式</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.0-chinese.html"><strong aria-hidden="true">6.2.</strong> 同步模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.1-chinese.html"><strong aria-hidden="true">6.2.1.</strong> 处理共享</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.2-chinese.html"><strong aria-hidden="true">6.2.2.</strong> 处理突变</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.0-chinese.html"><strong aria-hidden="true">6.3.</strong> 并发架构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.1-chinese.html"><strong aria-hidden="true">6.3.1.</strong> 活动对象</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.2-chinese.html"><strong aria-hidden="true">6.3.2.</strong> 监控对象</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.3-chinese.html"><strong aria-hidden="true">6.3.3.</strong> 半同步/半异步</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.0-chinese.html"><strong aria-hidden="true">6.4.</strong> 最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.1-chinese.html"><strong aria-hidden="true">6.4.1.</strong> 通常情况</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.2-chinese.html"><strong aria-hidden="true">6.4.2.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.3-chinese.html"><strong aria-hidden="true">6.4.3.</strong> 内存模型</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 数据结构</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Data-Structures/10.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 有锁结构</a></li><li class="chapter-item expanded "><a href="../../../content/Data-Structures/10.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 无锁结构</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 更多信息</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.1-chinese.html"><strong aria-hidden="true">8.1.</strong> 挑战</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 时间库</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.3-chinese.html"><strong aria-hidden="true">8.3.</strong> CppMem-概述</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 术语表</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">ConcurrencyWithModernCpp</h1>

                    <div class="right-buttons">
                                                <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="使用cppmem进行优化"><a class="header" href="#使用cppmem进行优化">使用CppMem进行优化</a></h1>
<p>我们从一个简单的程序开始，然后对其不断地进行改进。这里，使用CppMem验证的每个步骤。<a href="http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem">CppMem</a>是一个交互式工具，用于研究小代码段中C++内存模型的行为。</p>
<p>首先，来写个简单的程序：</p>
<pre><code class="language-c++">// ongoingOptimisation.cpp

#include &lt;iostream&gt;
#include &lt;thread&gt;

int x = 0;
int y = 0;

void writing() {
  x = 2000;
  y = 11;
}

void reading() {
  std::cout &lt;&lt; &quot;y: &quot; &lt;&lt; y &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; std::endl;
}

int main() {
  std::thread thread1(writing);
  std::thread thread2(reading);
  thread1.join();
  thread2.join();
}
</code></pre>
<p>程序很简单，由两个线程<code>thread1</code>和<code>thread2</code>构成。<code>thread1</code>写入x和y，<code>thread2</code>以相反的顺序读取值y和x。这看起来很简单，但这个简单的程序，却会给了我们三个不同的结果:</p>
<p><img src="../../../images/detail/Case-Studies/37.png" alt="" /></p>
<p>对程序优化之前，需要确定两个问题：</p>
<ol>
<li>程序的定义都明确吗？是否存在数据竞争？</li>
<li>x和y可能是哪些值?</li>
</ol>
<p>第一个问题往往很难回答。首先，考虑第一个问题的答案；其次，使用CppMem验证推理。当我想到了第一个问题的答案，就可以很容易地确定第二个问题的答案。我在一个表中给出了x和y的可能值。</p>
<p>但是，还没有解释持续优化是什么意思。其实很简单，通过弱化C++的内存序来不断优化程序。以下是优化步骤：</p>
<ul>
<li>非原子变量</li>
<li>锁</li>
<li>使用顺序一致语义的原子变量</li>
<li>使用获取-释放语义的原子变量</li>
<li>使用自由语义的原子变量</li>
<li>Volatile变量</li>
</ul>
<p>开始持续优化之旅之前，应该先对CppMem有一个基本的了解。在CppMem章节中，会提供了一个简单的介绍。</p>
<h2 id="cppmem-非原子变量"><a class="header" href="#cppmem-非原子变量">CppMem: 非原子变量</a></h2>
<p>使用<code>run</code>按钮可以立即显示数据竞争。更准确地说，上面的程序有两个数据竞争，因为变量<code>x</code>和<code>y</code>的访问都不受保护。因此，该程序具有未定义行为。在C++术语中，这意味着程序在玩火，你的电脑甚至会着火(笑)。</p>
<p>因此，我们不能得到x和y的准确值。</p>
<blockquote>
<p><strong>关于int型的变量</strong></p>
<p>只要int变量是自然对齐的，那么大多数主流架构对int变量的访问都是原子性的。自然对齐意味着在32位或64位体系结构中，32位int变量必须有一个能被4整除的地址。这是因为，C++11中可以调整数据类型的对齐方式。</p>
<p>必须强调的是，我并不是建议你像使用原子int那样使用int型变量。我只是想指出，在这种情况下，编译器比C++11标准提供了更多保证。如果过于依赖于编译器，那么程序就很可能不符合C++标准，因此可能会在其他硬件平台上运行出错。</p>
</blockquote>
<p>这就是我的推理内容。现在，我们应该看看CppMem关于程序未定义行为的报告。</p>
<p>CppMem允许我将程序剪裁到最小。</p>
<pre><code class="language-c++">int main() {
  int x = 0;
  int y = 0;
  { { { {
        x = 2000;
        y = 11;
        }
    |||{
        y;
        x;
       }
  } } }
}
</code></pre>
<p>可以使用大括号(第4行和第12行)和管道符号(第8行)在CppMem中定义一个线程。因为我对变量x和y的输出不感兴趣，所以只在第9行和第10行读取它们。</p>
<p>这是CppMem的理论部分，下面就来实践一下。</p>
<p><strong>分析</strong></p>
<p>执行程序时，CppMem会在(1)处提示，线程交错有四种可能性，其中有一种有竞争的。只有在第一次执行时，结果是一致的。现在，我可以使用CppMem在四个执行(2)之间进行切换，并分析示意图(3)。</p>
<p><img src="../../../images/detail/Case-Studies/38.png" alt="" /></p>
<p>通过分析图表，可以最大程度地利用CppMem。</p>
<p><strong>第一次执行</strong></p>
<p><img src="../../../images/detail/Case-Studies/39.png" alt="" /></p>
<p>节点表示程序的表达式，箭头表示表达式之间的关系。从图中的注释中我可以得出什么结论呢?</p>
<ul>
<li>a:Wna x = 0：第一个表达式(a)，向非原子变量x中写入0。</li>
<li>sb (前序，sequenced-before)：第一个表达式(a)执行的顺序在第二个表达式(b)之前就能确定。表达式(c)和(d)、(e)和(f)之间也存在这种关系。</li>
<li>rf (读取，read from)：(e)从(b)中读取y的值，(f)从(a)中读取x的值。</li>
<li>sw (同步，synchronizes-with)：因为表达式(f)在一个单独的线程中执行，所以(a)与(f)同步。线程创建之前发生的所有事情都是可见的，而线程的创建可以看作是一个同步点。由于对称性，(b)和(e)之间也存在同样的关系。</li>
<li>dr (数据竞争，data race)：变量x和y的读写之间有数据竞争，所以程序有未定义行为。</li>
</ul>
<blockquote>
<p><strong>为什么顺序一致的执行?</strong></p>
<p>因为x和y在主线程中初始化(a)和(b)，所以执行顺序一致。(c)和(d)中的x和y在内存模型上不是顺序一致的。</p>
</blockquote>
<p>接下来的三次执行，都不是顺序一致的。</p>
<p><strong>第二次执行</strong></p>
<p><img src="../../../images/detail/Case-Studies/40.png" alt="" /></p>
<p>(e)从(d)中读取“不一致”的y值，并且(d)的写入与(e)的读取同时发生。</p>
<p><strong>第三次执行</strong></p>
<p><img src="../../../images/detail/Case-Studies/41.png" alt="" /></p>
<p>与前一个执行对称，(f)同时从(c)中读取x。</p>
<p><strong>第四次执行</strong></p>
<p><img src="../../../images/detail/Case-Studies/42.png" alt="" /></p>
<p>现在，就开始乱套了。(e)和(f)同时从表达式(d)和(c)中读出x和y。</p>
<p><strong>简单的总结一下</strong></p>
<p>虽然我只是使用了CppMem的默认配置，但是获得了很多有价值的信息。特别是CppMem的图形化显示：</p>
<ul>
<li>x和y的所有可能的组合：(0,0)、(11,0)、(0,2000)和(11,2000)。</li>
<li>该程序至少有一个数据竞争，因此会触发未定义行为。</li>
<li>四种可能的执行方式中，只有一种是顺序一致的。</li>
</ul>
<blockquote>
<p><strong>使用volatile</strong></p>
<p>从内存模型的角度来看，对x和y使用限定符volatile与x和y的非同步访问没有区别。</p>
<p>CppMem: 使用volatile的不同步访问</p>
<pre><code class="language-c++">int main() {
volatile int x = 0;
volatile int y = 0;
  { { { 
    {
      x = 2000;
      y = 11;
    }
  ||| 
    {
      y;
      x;
    }
  } } }
}
</code></pre>
<p>CppMem生成与前一个示例相同的图。原因很简单，C++中volatile不具备多线程语义功能。</p>
</blockquote>
<p>这个例子中，x和y的访问没有同步，因此会出现数据竞争，产生未定义行为。最直接的同步方式，当然是使用锁。</p>
<h2 id="cppmem-锁"><a class="header" href="#cppmem-锁">CppMem: 锁</a></h2>
<p>两个线程<code>thread1</code>和<code>thread2</code>都使用了相同的互斥锁，且包装在<code>std::lock_guard</code>中。</p>
<pre><code class="language-c++">// ongoingOptimisationLock.cpp

#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

int x = 0;
int y = 0;

std::mutex mut;

void writing() {
  std::lock_guard&lt;std::mutex&gt; guard(mut);
  x = 2000;
  y = 11;
}

void reading() {
  std::lock_guard&lt;std::mutex&gt; guard(mut);
  std::cout &lt;&lt; &quot;y: &quot; &lt;&lt; y &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; std::endl;
}

int main() {
  std::thread thread1(writing);
  std::thread thread2(reading);
  thread1.join();
  thread2.join();
}
</code></pre>
<p>程序没啥问题，根据(thread1与thread2)执行顺序，要么是读后写，要么是先写后读。下面展示了x和y值的几种可能：</p>
<table><thead><tr><th align="center">y</th><th align="center">x</th><th align="center">有可能吗？</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">0</td><td align="center">有</td></tr>
<tr><td align="center">11</td><td align="center">0</td><td align="center"></td></tr>
<tr><td align="center">0</td><td align="center">2000</td><td align="center"></td></tr>
<tr><td align="center">11</td><td align="center">2000</td><td align="center">有</td></tr>
</tbody></table>
<blockquote>
<p><strong>CppMem中使用<code>std::lock_guard</code></strong></p>
<p>我没找到在CppMem中使用<code>std::lock_guard</code>的方法。如果你知道如何实现它，请告诉我一下 ：）</p>
</blockquote>
<p>锁的易用性比较好，但同步性价比太低。接下来使用原子变量，并尝试一种更轻量级的策略。</p>
<h2 id="cppmem-顺序一致语义的原子变量"><a class="header" href="#cppmem-顺序一致语义的原子变量">CppMem: 顺序一致语义的原子变量</a></h2>
<p>如果没有指定的内存序，则使用顺序一致。顺序一致保证每个线程按照源代码顺序执行，并且所有线程都遵循相同的全局序。</p>
<p>这里有个使用原子的优化版本。</p>
<pre><code class="language-c++">// ongoingOptimisationSequentialConsistency.cpp

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

std::atomic&lt;int&gt; x{ 0 };
std::atomic&lt;int&gt; y{ 0 };

void writing(){
  x.store(2000);
  y.store(11);
}

void reading() {
  std::cout &lt;&lt; y.load() &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; x.load() &lt;&lt; std::endl;
}

int main() {
  std::thread thread1(writing);
  std::thread thread2(reading);
  thread1.join();
  thread2.join();
}
</code></pre>
<p>我们来分析一下这段代码。因为x和y是原子变量，所以没有数据竞争。因此，只剩下一个问题需要回答。x和y可能的值是什么？这个问题也不难，由于顺序一致，所有线程都必须遵循相同的全局序。</p>
<p>实际执行的情况：</p>
<ul>
<li><code>x.store(2000);</code>先行于<code> y.store(11);</code></li>
<li><code>std::cout &lt;&lt; y.load() &lt;&lt; &quot; &quot;;</code>先行于<code>std::cout &lt;&lt; x.load() &lt;&lt; std::endl;</code></li>
</ul>
<p>因此，如果<code>y.load()</code>的值为11，则<code>x.load()</code>的值肯定不能为0，因为<code>x.store(2000)</code>在<code>y.store(11)</code>之前已经执行了。</p>
<p>x和y的其他所有值都是有可能，下面是导致x和y有三组不同值的原因：</p>
<ol>
<li><code>thread1</code>先行完成于<code>thread2 </code></li>
<li><code>thread2</code>先行完成于<code>thread1</code></li>
<li><code>thread1</code> 执行<code>x.store(2000)</code>先行于<code>thread2</code>执行完成</li>
</ol>
<p>那么x和y的所有可能性：</p>
<table><thead><tr><th align="center">y</th><th align="center">x</th><th align="center">有可能吗？</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">0</td><td align="center">有</td></tr>
<tr><td align="center">11</td><td align="center">0</td><td align="center"></td></tr>
<tr><td align="center">0</td><td align="center">2000</td><td align="center">有</td></tr>
<tr><td align="center">11</td><td align="center">2000</td><td align="center">有</td></tr>
</tbody></table>
<p>接下来使用CppMem验证一下我的猜想。</p>
<p><strong>CppMem</strong></p>
<pre><code class="language-c++">int main() {
  atomic_int x = 0; 
  atomic_int y = 0;
  {{{ {
        x.store(2000);
        y.store(11);
      }
  |||{
        y.load();
        x.load();
      }
  }}};
  return 0; }
</code></pre>
<p>首先介绍一些语法知识，CppMem为<code>std::atomic&lt;int&gt;</code>专门定义有<code>atomic_int</code>类型。</p>
<p>执行程序时，我被候选执行程序的数量(384个)吓了一跳。</p>
<p><img src="../../../images/detail/Case-Studies/43.png" alt="" /></p>
<p>有384个可能的执行候选，只有6个是顺序一致的，没有候选有数据竞争。不过，我只对6个顺序一致的候选感兴趣。</p>
<p>我使用选项(2)获得六个带注解的示意图。</p>
<p>我们已经知道，因为顺序一致，除了<code>y = 11</code>和<code>x = 0</code>外，其他可能值都是可能的。现在我很好奇，哪些线程交错会产生不同的x和y呢?</p>
<p><strong>(y = 0, x = 0)</strong></p>
<p><img src="../../../images/detail/Case-Studies/44.png" alt="" /></p>
<p><strong>(y = 0, x = 2000)</strong></p>
<p><img src="../../../images/detail/Case-Studies/45.png" alt="" /></p>
<p><img src="../../../images/detail/Case-Studies/46.png" alt="" /></p>
<p><img src="../../../images/detail/Case-Studies/47.png" alt="" /></p>
<p><img src="../../../images/detail/Case-Studies/48.png" alt="" /></p>
<p><strong>(y = 11, x = 2000)</strong></p>
<p><img src="../../../images/detail/Case-Studies/49.png" alt="" /></p>
<p>分析还没结束，我感兴趣的是：指令序列与这六个图如何对应?</p>
<p><strong>指令序列</strong></p>
<p>我给每个指令序列分配了相应的图示。</p>
<p><img src="../../../images/detail/Case-Studies/50.png" alt="" /></p>
<p>让我们从简单的例子开始分析：</p>
<ul>
<li>(1)：x和y的值为0，因为<code>y.load()</code>和<code>x.load()</code>在操作<code>x.store(2000)</code>和<code>y.store(11)</code>之前完成。</li>
<li>(6): 所有的加载操作都发生在存储操作之后，所以y的值是11，x的值是2000。</li>
<li>(2), (3), (4), (5): 这几个是更有趣的例子，y的值是0，x的值是2000。图中的黄色箭头(sc)是我推理的关键，它们代表指令序列。让我们看看(2)是怎么执行的：
<ul>
<li>(2)中黄色箭头(sc)的顺序是：<code>写入x = 2000</code> ⇒ <code>读取 y = 0 </code>⇒ <code>写入 y = 11</code> ⇒ <code>读取 x = 2000</code>。该序列对应于第二次线程交错(2)时的指令序列。</li>
</ul>
</li>
</ul>
<p>接下来，让我们打破顺序一致的束缚，使用获取-释放语义。</p>
<h2 id="cppmem获取-释放语义的原子变量"><a class="header" href="#cppmem获取-释放语义的原子变量">CppMem：获取-释放语义的原子变量</a></h2>
<p>与线程之间进行同步的顺序一致不同，获取-释放语义的同步，发生在同一原子变量的(原子)操作之间。基于这个前提，获取-释放语义更轻，也更快。</p>
<p>展示一段使用获取-释放语义的代码。</p>
<pre><code class="language-c++">// ongoingOptimisationAcquireRelease.cpp

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

std::atomic&lt;int&gt;x{ 0 };
std::atomic&lt;int&gt; y{ 0 };

void writing() {
  x.store(2000, std::memory_order_relaxed);
  y.store(11, std::memory_order_release);
}

void reading() {
  std::cout &lt;&lt; y.load(std::memory_order_acquire) &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; x.load(std::memory_order_relaxed) &lt;&lt; std::endl;
}

int main() {
  std::thread thread1(writing);
  std::thread thread2(reading);
  thread1.join();
  thread2.join();
}
</code></pre>
<p>所有的操作都是原子的，所以程序没啥问题。再多看几眼，你会发现更多东西，<code>y</code>上的原子操作附加了<code>std::memory_order_release</code>(第12行)和<code>std::memory_order_acquire</code>标记(第16行)。与之相反，<code>x</code>上的原子操作是用<code>std::memory_order_relax</code>标记(第11行和第17行)，所以<code>x</code>没有同步和顺序约束。<code>x</code>和<code>y</code>可能值，只能由<code>y</code>给出答案了。</p>
<ul>
<li><code>y.store(11,std::memory_order_release)</code>同步于<code>y.load(std::memory_order_acquire)</code></li>
<li><code>x.store(2000,std::memory_order_relaxed)</code>先见于<code>y.store(11, std::memory_order_release)</code></li>
<li><code>y.load(std::memory_order_acquire)</code>先见于<code>x.load(std::memory_order_relaxed)</code></li>
</ul>
<p>进行更详细的描述：关键点在于，第12行<code>y</code>的存储与第16行<code>y</code>的加载是同步的。因为操作发生在相同的原子变量上，所以使用的是获取-释放语义。<code>y</code>在第12行中使用<code>std::memory_order_release</code>，第16行中使用<code>std::memory_order_acquire</code>，因此<code>x.store(2000, std:: memory_order_relax)</code>不能在<code>y.store (std::memory_order_release)</code>之后执行，而<code>x.load()</code>也不能在<code>y.load()</code>之前执行。</p>
<p>获取-释放语义的推理比之前的顺序一致的推理复杂许多，但是<code>x</code>和<code>y</code>的可能值是相同的。只有<code>y == 11</code>和<code>x == 0</code>的组合是不可能的。</p>
<p>有三种可能的线程交错，它们会产生不同<code>x</code>和<code>y</code>：</p>
<ul>
<li><code>thread1</code>先于 <code>thread2</code>执行</li>
<li><code>thread2</code>先于<code> thread1</code>执行</li>
<li><code>thread1</code>执行<code> x.store(2000)</code>先于<code>thread2</code>执行</li>
</ul>
<p>以下是x和y的所有可能值：</p>
<table><thead><tr><th align="center">y</th><th align="center">x</th><th align="center">有可能吗？</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">0</td><td align="center">有</td></tr>
<tr><td align="center">11</td><td align="center">0</td><td align="center"></td></tr>
<tr><td align="center">0</td><td align="center">2000</td><td align="center">有</td></tr>
<tr><td align="center">11</td><td align="center">2000</td><td align="center">有</td></tr>
</tbody></table>
<p>继续使用CppMem验证猜想。</p>
<p><strong>CppMem</strong></p>
<pre><code class="language-c++">int main() {
  atomic_int x = 0; 
  atomic_int y = 0;
  {{{ {
        x.store(2000,memory_order_relaxed);
        y.store(11,memory_order_release);
      }
  |||{
        y.load(memory_order_acquire);
        x.load(memory_order_relaxed);
      }
  }}};
}
</code></pre>
<p>我们已经知道，除了(y = 11, x = 0)之外，其他结果都有可能。</p>
<p><strong>可能的执行顺序</strong></p>
<p>这里只引用执行一致的三个图。从图中可以看出，<code>y</code>的存储-释放操作与<code>y的</code>加载- 获取操作之间，有获取-释放语义存在。在主线程或单独的线程中读取<code>y</code>(rf)是没有区别的。图中显示了同步关系，是用一个带sw注释的箭头进行表示的。</p>
<p><strong>(y = 0, x = 0)</strong></p>
<p><img src="../../../images/detail/Case-Studies/51.png" alt="" /></p>
<p><strong>(y = 0, x = 2000)</strong></p>
<p><img src="../../../images/detail/Case-Studies/52.png" alt="" /></p>
<p><strong>(y = 11, x = 2000)</strong></p>
<p><img src="../../../images/detail/Case-Studies/53.png" alt="" /></p>
<p><code>x</code>不一定是原子的?! 好吧，这是我第一个错误的假设，来看下原因。</p>
<h2 id="cppmem原子变量和非原子变量混用"><a class="header" href="#cppmem原子变量和非原子变量混用">CppMem：原子变量和非原子变量混用</a></h2>
<p>获取-释放语义中，典型的误解是假定获取操作正在等待释放操作。基于这个错误的假设，你可能认为<code>x</code>不必是一个原子变量，从而可以进一步优化程序。</p>
<pre><code class="language-c++">// ongoingOptimisationAcquireReleaseBroken.cpp

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

int x = 0;
std::atomic&lt;int&gt; y{ 0 };

void writing() {
  x = 2000;
  y.store(11, std::memory_order_release);
}

void reading() {
  std::cout &lt;&lt; y.load(std::memory_order_acquire) &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; x &lt;&lt; std::endl;
}

int main() {
  std::thread thread1(writing);
  std::thread thread2(reading);
  thread1.join();
  thread2.join();
}
</code></pre>
<p>该程序在<code>x</code>上有一个数据竞争，因此存在未定义行为。获取-释放语义能够保证<code>y.store(11, std::memory_order_release)</code>(第12行)在<code>y.load(std::memory_order_acquire)</code>(第16行)之前执行，即<code>x = 2000</code>在第17行读取x之前执行。如果没有，读取<code>x</code>的同时，对<code>x</code>进行写入。所以会并发访问一个共享变量，并且其中一个操作是写操作。从程序定义上来说，这就是一场数据争霸。</p>
<p>使用CppMem更清楚地展示我的观点。</p>
<p><strong>CppMem</strong></p>
<pre><code class="language-c++">int main() {
  int x = 0;
  atomic_int y = 0; 
  {{{ {
         x = 2000;
         y.store(11, memory_order_release);
      }
  ||| {
         y.load(memory_order_acquire);
         x;
      }
  }}}
}
</code></pre>
<p>当一个线程正在写<code>x = 2000</code>，而另一个线程正在读x时，就会发生数据竞争。我们在相应的黄色箭头上得到一个dr(数据竞争)。</p>
<p><img src="../../../images/detail/Case-Studies/54.png" alt="" /></p>
<p>接下来，就是优化过程中的最后一步了——自由语序。</p>
<h2 id="cppmem-自由语序的原子变量"><a class="header" href="#cppmem-自由语序的原子变量">CppMem: 自由语序的原子变量</a></h2>
<p>宽松的语义对原子操作没有同步和排序约束，仅保证操作的原子性。</p>
<pre><code class="language-c++">// ongoingOptimisationRelaxedSemantic.cpp

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

std::atomic&lt;int&gt; x{ 0 };
std::atomic&lt;int&gt; y{ 0 };

void writing() {
  x.store(2000, std::memory_order_relaxed);
  y.store(11, std::memory_order_relaxed);
}

void reading() {
  std::cout &lt;&lt; y.load(std::memory_order_relaxed) &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; x.load(std::memory_order_relaxed) &lt;&lt; std::endl;
}

int main() {
  std::thread thread1(writing);
  std::thread thread2(reading);
  thread1.join();
  thread2.join();
}
</code></pre>
<p>对于自由语义，之前的基本问题很容易回答。还记得问题是什么吗</p>
<ol>
<li>程序是否有定义良好的行为?</li>
<li><code>x</code>和<code>y</code>有哪些可能?</li>
</ol>
<p>一方面，<code>x</code>和<code>y</code>的所有操作都是原子的，所以程序是定义良好的。另一方面，对线程可能的交错没有限制。结果可能是<code>thread2</code>以不同的顺序看到<code>thread1</code>上的操作。这是在我们在优化过程中，<code>thread2</code>第一次可以显示<code>x == 0</code>和<code>y == 11</code>，因此所有x和y的组合都有可能。</p>
<table><thead><tr><th align="center">y</th><th align="center">x</th><th align="center">有可能吗？</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">0</td><td align="center">有</td></tr>
<tr><td align="center">11</td><td align="center">0</td><td align="center">有</td></tr>
<tr><td align="center">0</td><td align="center">2000</td><td align="center">有</td></tr>
<tr><td align="center">11</td><td align="center">2000</td><td align="center">有</td></tr>
</tbody></table>
<p>我想知道<code>x = 0</code>和<code>y = 11</code>时，CppMem的示意图是怎样的?</p>
<p><strong>CppMem</strong></p>
<pre><code class="language-c++">int main() {
  atomic_int x = 0;
  atomic_int y = 0; 
  {{{ {
         x.store(2000, memory_order_relaxed);
         y.store(11, memory_order_release);
      }
  ||| {
         y.load(memory_order_acquire);
         x.load(memory_order_relaxed);
      }
  }}}
}
</code></pre>
<p>这就是CppMem的程序段，现在来看看产生的关系图表。</p>
<p><img src="../../../images/detail/Case-Studies/55.png" alt="" /></p>
<p>尽管<code>x</code>(第5行)的写入顺序排在<code>y</code>(第6行)的写入顺序之前，但仍然会发生<code>x</code>读取值0(第10行)，<code>y</code>读取值11(第9行)的情况。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../../content/The-Details/Case-Studies/4.2-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../../content/The-Details/Case-Studies/4.4-chinese.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../../content/The-Details/Case-Studies/4.2-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../../content/The-Details/Case-Studies/4.4-chinese.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
