<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>求向量元素的加和 - ConcurrencyWithModernCpp</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../../favicon.svg">
                        <link rel="shortcut icon" href="../../../favicon.png">
                <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
                <link rel="stylesheet" href="../../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../content/Reader-Testimonials.html"><strong aria-hidden="true">1.</strong> 读者推荐</a></li><li class="chapter-item expanded "><a href="../../../content/Source-Code.html"><strong aria-hidden="true">2.</strong> 代码说明</a></li><li class="chapter-item expanded "><a href="../../../content/How-you-should-read-the-book.html"><strong aria-hidden="true">3.</strong> 如何阅读</a></li><li class="chapter-item expanded "><a href="../../../content/History-Quick-Overview.html"><strong aria-hidden="true">4.</strong> C++并发历史概述</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 详细介绍</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.0-chinese.html"><strong aria-hidden="true">5.1.</strong> 内存模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.1-chinese.html"><strong aria-hidden="true">5.1.1.</strong> 内存模型的基础知识</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.2-chinese.html"><strong aria-hidden="true">5.1.2.</strong> 编程协议</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.3-chinese.html"><strong aria-hidden="true">5.1.3.</strong> 原子操作</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.4-chinese.html"><strong aria-hidden="true">5.1.4.</strong> 同步和顺序</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.5-chinese.html"><strong aria-hidden="true">5.1.5.</strong> 栅栏(Fences)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.0-chinese.html"><strong aria-hidden="true">5.2.</strong> 多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.1-chinese.html"><strong aria-hidden="true">5.2.1.</strong> 线程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.2-chinese.html"><strong aria-hidden="true">5.2.2.</strong> 共享数据</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.3-chinese.html"><strong aria-hidden="true">5.2.3.</strong> 线程-本地数据</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.4-chinese.html"><strong aria-hidden="true">5.2.4.</strong> 条件变量</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.5-chinese.html"><strong aria-hidden="true">5.2.5.</strong> 任务</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.0-chinese.html"><strong aria-hidden="true">5.3.</strong> 标准库的并行算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.1-chinese.html"><strong aria-hidden="true">5.3.1.</strong> 执行策略</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.2-chinese.html"><strong aria-hidden="true">5.3.2.</strong> 算法</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.3-chinese.html"><strong aria-hidden="true">5.3.3.</strong> 新算法</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.4-chinese.html"><strong aria-hidden="true">5.3.4.</strong> 性能概况</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.0-chinese.html"><strong aria-hidden="true">5.4.</strong> 案例研究</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.1-chinese.html" class="active"><strong aria-hidden="true">5.4.1.</strong> 求向量元素的加和</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.2-chinese.html"><strong aria-hidden="true">5.4.2.</strong> 单例模式：线程安全的初始化</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.3-chinese.html"><strong aria-hidden="true">5.4.3.</strong> 使用CppMem进行优化</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.4-chinese.html"><strong aria-hidden="true">5.4.4.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.0-chinese.html"><strong aria-hidden="true">5.5.</strong> C++20/23的特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.1-chinese.html"><strong aria-hidden="true">5.5.1.</strong> 关于执行</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.2-chinese.html"><strong aria-hidden="true">5.5.2.</strong> 可协作中断的线程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.3-chinese.html"><strong aria-hidden="true">5.5.3.</strong> 原子智能指针</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.4-chinese.html"><strong aria-hidden="true">5.5.4.</strong> 扩展特性</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.5-chinese.html"><strong aria-hidden="true">5.5.5.</strong> 门闩和栅栏</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.6-chinese.html"><strong aria-hidden="true">5.5.6.</strong> 协程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.7-chinese.html"><strong aria-hidden="true">5.5.7.</strong> 事务性内存</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.8-chinese.html"><strong aria-hidden="true">5.5.8.</strong> 任务块</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.0-chinese.html"><strong aria-hidden="true">6.1.</strong> 模式和最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.1-chinese.html"><strong aria-hidden="true">6.1.1.</strong> 相关历史</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.2-chinese.html"><strong aria-hidden="true">6.1.2.</strong> 价值所在</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.3-chinese.html"><strong aria-hidden="true">6.1.3.</strong> 模式与最佳实践</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.4-chinese.html"><strong aria-hidden="true">6.1.4.</strong> 反模式</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.0-chinese.html"><strong aria-hidden="true">6.2.</strong> 同步模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.1-chinese.html"><strong aria-hidden="true">6.2.1.</strong> 处理共享</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.2-chinese.html"><strong aria-hidden="true">6.2.2.</strong> 处理突变</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.0-chinese.html"><strong aria-hidden="true">6.3.</strong> 并发架构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.1-chinese.html"><strong aria-hidden="true">6.3.1.</strong> 活动对象</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.2-chinese.html"><strong aria-hidden="true">6.3.2.</strong> 监控对象</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.3-chinese.html"><strong aria-hidden="true">6.3.3.</strong> 半同步/半异步</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.0-chinese.html"><strong aria-hidden="true">6.4.</strong> 最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.1-chinese.html"><strong aria-hidden="true">6.4.1.</strong> 通常情况</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.2-chinese.html"><strong aria-hidden="true">6.4.2.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.3-chinese.html"><strong aria-hidden="true">6.4.3.</strong> 内存模型</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 数据结构</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Data-Structures/10.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 有锁结构</a></li><li class="chapter-item expanded "><a href="../../../content/Data-Structures/10.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 无锁结构</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 更多信息</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.1-chinese.html"><strong aria-hidden="true">8.1.</strong> 挑战</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 时间库</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.3-chinese.html"><strong aria-hidden="true">8.3.</strong> CppMem-概述</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 术语表</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">ConcurrencyWithModernCpp</h1>

                    <div class="right-buttons">
                                                <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="求向量元素的加和"><a class="header" href="#求向量元素的加和">求向量元素的加和</a></h1>
<p>向<code>std::vector</code>中添加元素最快的方法是哪种？为了得到答案，我准备向<code>std::vector</code>中填充了一亿个数值，这些数在1~10之间<a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">均匀分布</a> 。我们的任务是用各种方法计算这些数字的和，并添加执行时间作为性能指标。本节将讨论原子、锁、线程本地数据和任务。</p>
<h2 id="单线程方式"><a class="header" href="#单线程方式">单线程方式</a></h2>
<p>最直接的方式是使用for循环进行数字的添加。</p>
<p><strong>for循环</strong></p>
<p>下面的代码中，第27行进行加和计算。</p>
<pre><code class="language-c++">// calculateWithLoop.cpp

#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

constexpr long long size = 100000000;

int main() {

  std::cout &lt;&lt; std::endl;

  std::vector&lt;int&gt;randValues;
  randValues.reserve(size);

  // random values
  std::random_device seed;
  std::mt19937 engine(seed());
  std::uniform_int_distribution&lt;&gt; uniformDIst(1, 10);
  for (long long i = 0; i &lt; size; ++i)
    randValues.push_back(uniformDIst(engine));

  const auto sta = std::chrono::steady_clock::now();

  unsigned long long sum = {};
  for (auto n : randValues)sum += n;

  const std::chrono::duration&lt;double&gt; dur =
    std::chrono::steady_clock::now() - sta;

  std::cout &lt;&lt; &quot;Time for mySumition &quot; &lt;&lt; dur.count()
    &lt;&lt; &quot;seconds&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; sum &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>我的电脑可够快？</p>
<p><img src="../../../images/detail/Case-Studies/11.png" alt="" /></p>
<p>显式地使用循环没什么技术含量。大多数情况下，可以使用标准模板库中的算法。</p>
<p><strong>使用std::accumulate进行加和计算</strong></p>
<p><code>std::accumulate</code>是计算向量和的正确选择，下面代码展示了<code>std::accumulate</code>的使用方法。完整的源文件可以在本书的参考资料中找到。</p>
<pre><code class="language-c++">// calculateWithStd.cpp
...
const unsigned long long sum = std::accumulate(randValues.begin(),
              randValues.end(), 0);
...
</code></pre>
<p>Linux上，<code>std::accumulate</code>的性能与for循环的性能大致相同，而在Windows上使用<code>std::accumulate</code>会产生很大的性能收益。</p>
<p><img src="../../../images/detail/Case-Studies/12.png" alt="" /></p>
<p>现在有了基线参考时间，就可以继续剩余的两个单线程场景了：使用锁和原子操作。为什么是这两个场景？我们需要有性能数字佐证，在没有竞争的情况下，锁和原子操作对数据进行保护，需要付出多大的性能代价。</p>
<p><strong>使用锁进行保护</strong></p>
<p>如果使用锁保护对求和变量的访问，需要回答两个问题。</p>
<ol>
<li>无争抢的同步锁，需要多大的代价?</li>
<li>最优的情况下，锁能有多快？</li>
</ol>
<p>这里使用<code>std::lock_guard</code>的方式，完整源码可在本书资源中找到。</p>
<pre><code class="language-c++">// calculateWithLock.cpp
...
std::mutex myMutex;
for (auto i: randValues){
	std::lock_guard&lt;std::mutex&gt; myLockGuard(myMutex);
	sum += i;
}
...
</code></pre>
<p>执行时间与预期的一样：对变量<code>sum</code>进行保护后，程序变得很慢。</p>
<p><img src="../../../images/detail/Case-Studies/13.png" alt="" /></p>
<p><code>std::lock_guard</code>的方式大约比<code>std::accumulate </code>慢50-150倍。接下来，让我们来看看原子操作的表现。</p>
<p><strong>使用原子操作进行保护</strong></p>
<p>对于原子操作的问题与锁一样：</p>
<ol>
<li>原子同步的代价有多大?</li>
<li>如果没有竞争，原子操作能有多快?</li>
</ol>
<p>还有一个问题：原子操作和锁的性能有多大差异?</p>
<pre><code class="language-c++">// calculateWithAtomic.cpp

#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

constexpr long long size = 100000000;

int main() {

  std::cout &lt;&lt; std::endl;

  std::vector&lt;int&gt;randValues;
  randValues.reserve(size);

  // random values
  std::random_device seed;
  std::mt19937 engine(seed());
  std::uniform_int_distribution&lt;&gt; uniformDist(1, 10);
  for (long long i = 0; i &lt; size; ++i)
    randValues.push_back(uniformDist(engine));

  std::atomic&lt;unsigned long long&gt; sum = {};
  std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;sum.is_lock_free(): &quot;
    &lt;&lt; sum.is_lock_free() &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;

  auto sta = std::chrono::steady_clock::now();

  for (auto i : randValues) sum += i;

  std::chrono::duration&lt;double&gt; dur = std::chrono::steady_clock::now() - sta;


  std::cout &lt;&lt; &quot;Time for addition &quot; &lt;&lt; dur.count()
    &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; sum &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;
  
  sum = 0;
  sta = std::chrono::steady_clock::now();

  for (auto i : randValues) sum.fetch_add(i);

  dur = std::chrono::steady_clock::now() - sta;
  std::cout &lt;&lt; &quot;Time for addition &quot; &lt;&lt; dur.count()
    &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; sum &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>首先，第28行检查是否有锁，否则锁和原子操作就没有区别了。所有主流平台上，原子变量都是无锁的。然后，用两种方法计算加和。第33行使用<code>+=</code>操作符，第45行使用<code>fetch_add</code>方法。单线程情况下，两种方式相差不多；不过，我可以显式地指定<code>fetch_add</code>的内存序。关于这点将在下一小节中详细介绍。</p>
<p>下面是程序的结果。</p>
<p><img src="../../../images/detail/Case-Studies/14.png" alt="" /></p>
<p><img src="../../../images/detail/Case-Studies/15.png" alt="" /></p>
<p><strong>单线程场景总结</strong></p>
<ol>
<li>原子操作在Linux和Windows上的速度比<code>std::accumulate </code>要慢12 - 50倍。</li>
<li>在Linux和Windows上，原子操作的速度比锁快2 - 3倍。</li>
<li><code>std::accumulate</code>似乎在Windows上有更好的优化。</li>
</ol>
<p>进行多线程场景测试之前，用表总结了单线程执行的结果，时间单位是秒。</p>
<table><thead><tr><th align="center">操作系统(编译器)</th><th align="center">for循环</th><th align="center"><code>std::accumulate</code></th><th align="center">锁</th><th align="center">原子操作</th></tr></thead><tbody>
<tr><td align="center">Linux(GCC)</td><td align="center">0.07</td><td align="center">0.07</td><td align="center">3.34</td><td align="center">1.34/1.33</td></tr>
<tr><td align="center">Windows(cl.exe)</td><td align="center">0.08</td><td align="center">0.03</td><td align="center">4.07</td><td align="center">1.50/1.61</td></tr>
</tbody></table>
<h2 id="多线程使用共享变量进行求和"><a class="header" href="#多线程使用共享变量进行求和">多线程：使用共享变量进行求和</a></h2>
<p>使用四个线程并用共享变量进行求和，并不是最优的最优的方式，因为同步开销超过了性能收益。</p>
<p>还是那两个问题：</p>
<ol>
<li>使用锁和原子的求和方式，在性能上有什么不同?</li>
<li><code>std::accumulate</code>的单线程执行和多线程执行的性能表现有什么不同?</li>
</ol>
<p><strong>使用<code>std::lock_guard</code></strong></p>
<p>实现线程安全的求和，最简单方法是使用<code>std::lock_guard</code>。</p>
<pre><code class="language-c++">// synchronisationWithLock.cpp

#include&lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

constexpr long long size = 100000000;

constexpr long long fir = 25000000;
constexpr long long sec = 50000000;
constexpr long long thi = 75000000;
constexpr long long fou = 100000000;

std::mutex myMutex;

void sumUp(unsigned long long&amp; sum, const std::vector&lt;int&gt;&amp; val,
  unsigned long long beg, unsigned long long end) {
  for (auto it = beg; it &lt; end; ++it) {
    std::lock_guard&lt;std::mutex&gt; myLock(myMutex);
    sum += val[it];
  }
}

int main() {

  std::cout &lt;&lt; std::endl;

  std::vector&lt;int&gt; randValues;
  randValues.reserve(size);

  std::mt19937 engine;
  std::uniform_int_distribution&lt;&gt; uniformDist(1, 10);
  for (long long i = 0; i &lt; size; ++i)
    randValues.push_back(uniformDist(engine));

  unsigned long long sum = 0;
  const auto sta = std::chrono::steady_clock::now();

  std::thread t1(sumUp, std::ref(sum), std::ref(randValues), 0, fir);
  std::thread t2(sumUp, std::ref(sum), std::ref(randValues), fir, sec);
  std::thread t3(sumUp, std::ref(sum), std::ref(randValues), sec, thi);
  std::thread t4(sumUp, std::ref(sum), std::ref(randValues), thi, fou);

  t1.join();
  t2.join();
  t3.join();
  t4.join();

  std::chrono::duration&lt;double&gt; dur = std::chrono::steady_clock::now() - sta;
  std::cout &lt;&lt; &quot;Time for addition &quot; &lt;&lt; dur.count()
    &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; sum &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>程序很简单，函数<code>sumUp</code>(第20 - 26行)是需要线程完成的工作包。通过引用的方式得到变量<code>sum</code>和<code>std::vector val</code>，<code>beg</code>和<code>end</code>用来限定求和的范围，<code>std::lock_guard</code>(第23行)用于保护共享变量<code>sum</code>。每个线程(第43 - 46行)对四分之一的数据进行加和计算。</p>
<p>下面是我电脑上的性能数据：</p>
<p><img src="../../../images/detail/Case-Studies/16.png" alt="" /></p>
<p><img src="../../../images/detail/Case-Studies/17.png" alt="" /></p>
<p>因为<code>std::lock_guard</code>需要对行了同步，所以瓶颈在共享变量<code>sum</code>处。简单直接的解决方案：用轻量级的原子操作来替换重量级的锁。</p>
<blockquote>
<p>没有更改，为了简单起见，本小节之后只展示<code>sumUp</code>函数体。完整的示例，请参阅本书的参考资料。</p>
</blockquote>
<p><strong>使用原子变量</strong></p>
<p>求和变量<code>sum</code>是一个原子变量，就不再需要<code>std::lock_guard</code>。以下是修改后的求和函数。</p>
<pre><code class="language-c++">// synchronisationWithAtomic.cpp
...
void sumUp(std::atomic&lt;unsigned long long&gt;&amp; sum, const 	std::vector&lt;int&gt;&amp; val,
		unsigned long long beg, unsigned long long end){
	for (auto it = beg; it &lt; end; ++it){
		sum += val[it];
	}
}
</code></pre>
<p>我的Windows笔记本电脑的性能数据相当奇怪，耗时是使用<code>std::lock_guard</code>的两倍多。</p>
<p><img src="../../../images/detail/Case-Studies/18.png" alt="" /></p>
<p>除了使用<code>+=</code>操作符外，还可以使用<code>fetch_add</code>。</p>
<p><strong>使用fetch_add</strong></p>
<p>这次，代码的修改的更少，只是将求和表达式改为<code>sum.fetch_add(val[it])</code>。</p>
<pre><code class="language-c++">// synchronisationWithFetchAdd.cpp
...
void sumUp(std::atomic&lt;unsigned long long&gt;&amp; sum, const std::vector&lt;int&gt;&amp; val,
	unsigned long long beg, unsigned long long end){
	for (auto it = beg; it &lt; end; ++it){
		sum.fetch_add(val[it]);
	}
}
...
</code></pre>
<p>现在的性能与前面的例子相似，操作符<code>+=</code>和<code>fetch_add</code>之间貌似没有什么区别。</p>
<p><img src="../../../images/detail/Case-Studies/19.png" alt="" /></p>
<p>虽然<code>+=</code>操作和<code>fetch_add</code>在性能上没有区别，但是<code>fetch_add</code>有一个优势，可以显式地弱化内存序，并使用自由语义。</p>
<p><strong>使用自由语义的fetch_add</strong></p>
<pre><code class="language-c++">// synchronisationWithFetchAddRelaxed.cpp

...
  void sumUp(std::atomic&lt;unsigned long long&gt;&amp; sum, const std::vector&lt;int&gt;&amp; val,
             unsigned long long beg, unsigned long long end){
  for (auto it = beg; it &lt; end; ++it){
    sum.fetch_add(val[it], std::memory_order_relaxed);
  }
}
  
...
</code></pre>
<p>原子变量默认是顺序一致的。对于原子变量的加和和赋值，使用<code>fetch_add</code>是没问题的，也可以进行优化。我将求和表达式中的内存序调整为自由语义：<code>sum.fetch_add (val[it],std::memory_order_relaxed)</code>。自由语义是最弱的内存序，也是我们优化的终点。</p>
<p>这个用例中，自由语义能很好的完成工作，因为<code>fetch_add</code>进行的每个加和都是原子的，并且线程会进行同步。</p>
<p>因为是最弱的内存模型，所以性能最好。</p>
<p><img src="../../../images/detail/Case-Studies/20.png" alt="" /></p>
<p><strong>多线程使用共享变量求和总结</strong></p>
<p>性能数值的时间单位是秒。</p>
<table><thead><tr><th align="center">操作系统(编译器)</th><th align="center"><code>std::lock_guard</code></th><th align="center">原子 +=</th><th align="center">fetch_add</th><th align="center">fetch_add (使用自由内存序)</th></tr></thead><tbody>
<tr><td align="center">Linux(GCC)</td><td align="center">20.81</td><td align="center">7.78</td><td align="center">7.87</td><td align="center">7.66</td></tr>
<tr><td align="center">Windows(cl.exe)</td><td align="center">6.22</td><td align="center">15.73</td><td align="center">15.78</td><td align="center">15.01</td></tr>
</tbody></table>
<p>性能数据并不乐观，使用自由语义的共享原子变量，在四个线程的帮助下计算加和，其速度大约比使用<code>std::accumulate</code>算法的单个线程慢100倍。</p>
<p>结合前面的两种加和的策略，接下来会使用四个线程，并尽量减少线程之间的同步。</p>
<h2 id="线程本地的加和"><a class="header" href="#线程本地的加和">线程本地的加和</a></h2>
<p>接下来使用局部变量、线程本地数据和任务，可以最小化同步。</p>
<p><strong>使用本地变量</strong></p>
<p>每个线程都使用本地变量求和，所以可以在不同步的情况下完成自己的工作。不过，汇总局部变量的总和时需要进行同步。简单地说：只添加了4个同步，所以从性能的角度来看，使用哪种同步并不重要。我使用<code>std::lock_guard</code>和一个具有顺序一致语义和自由语义的原子变量。</p>
<p><strong>std::lock_guard</strong></p>
<p>使用<code>std::lock_guard</code>进行最小化同步的加和计算。</p>
<pre><code class="language-c++">// localVariable.cpp

#include &lt;mutex&gt;
#include&lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

constexpr long long size = 100000000;

constexpr long long fir = 25000000;
constexpr long long sec = 50000000;
constexpr long long thi = 75000000;
constexpr long long fou = 100000000;

std::mutex myMutex;

void sumUp(unsigned long long&amp; sum, const std::vector&lt;int&gt;&amp; val,
  unsigned long long beg, unsigned long long end) {
  unsigned long long tmpSum{};
  for (auto i = beg; i &lt; end; ++i) {
    tmpSum += val[i];
  }
  std::lock_guard&lt;std::mutex&gt; lockGuard(myMutex);
  sum += tmpSum;
}

int main() {

  std::cout &lt;&lt; std::endl;

  std::vector&lt;int&gt; randValues;
  randValues.reserve(size);

  std::mt19937 engine;
  std::uniform_int_distribution&lt;&gt; uniformDist(1, 10);
  for (long long i = 0; i &lt; size; ++i)
    randValues.push_back(uniformDist(engine));

  unsigned long long sum{};
  const auto sta = std::chrono::steady_clock::now();

  std::thread t1(sumUp, std::ref(sum), std::ref(randValues), 0, fir);
  std::thread t2(sumUp, std::ref(sum), std::ref(randValues), fir, sec);
  std::thread t3(sumUp, std::ref(sum), std::ref(randValues), sec, thi);
  std::thread t4(sumUp, std::ref(sum), std::ref(randValues), thi, fou);

  t1.join();
  t2.join();
  t3.join();
  t4.join();

  std::chrono::duration&lt;double&gt; dur = 
    std::chrono::steady_clock::now() - sta;


  std::cout &lt;&lt; &quot;Time for addition &quot; &lt;&lt; dur.count()
    &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; sum &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>第26和27行，将局部求和结果<code>tmpSum</code>添加到全局求和变量<code>sum</code>中。</p>
<p><img src="../../../images/detail/Case-Studies/21.png" alt="" /></p>
<p><img src="../../../images/detail/Case-Studies/22.png" alt="" /></p>
<p>接下来使用局部变量的示例中，只有函数求和方式发生了变化，所以只展示这个函数体实现。完整的程序代码，请参考源文件。</p>
<p><strong>使用顺序一致语义的原子变量</strong></p>
<p>让我们用一个原子变量来声明全局求和变量<code>sum</code>。</p>
<pre><code class="language-c++">// localVariableAtomic.cpp
...
void sumUp(std::atomic&lt;unsigned long long&gt;&amp; sum, const std::vector&lt;int&gt;&amp; val,
           unsigned long long beg, unsigned long long end){
  unsigned int long long tmpSum{};
  for (auto i = beg; i &lt; end; ++i){
    tmpSum += val[i];
  }
  sum+= tmpSum;
}
...
</code></pre>
<p>下面是具体的性能数据：</p>
<p><img src="../../../images/detail/Case-Studies/23.png" alt="" /></p>
<p><img src="../../../images/detail/Case-Studies/24.png" alt="" /></p>
<p><strong>使用自由语义的原子变量</strong></p>
<p>现在不使用默认的内存序，而使用的是自由语义。只需要保证，所有求和操作是原子的就好。</p>
<pre><code class="language-c++">// localVariableAtomicRelaxed.cpp
...
void sumUp(std::atomic&lt;unsigned long long&gt;&amp; sum, const std::vector&lt;int&gt;&amp; val,
           unsigned long long beg, unsigned long long end){
  unsigned int long long tmpSum{};
  for (auto i = beg; i &lt; end; ++i){
    tmpSum += val[i];
  }
  sum.fetch_add(tmpSum, std::memory_order_relaxed);
}
...
</code></pre>
<p>和预期一样，使用<code>std::lock_guard</code>，使用顺序一致的原子变量，或是使用自由语义的原子变量进行求和，在性能方面并没什么差异。</p>
<p><img src="../../../images/detail/Case-Studies/25.png" alt="" /></p>
<p><img src="../../../images/detail/Case-Studies/26.png" alt="" /></p>
<p>线程本地数据不同于其他类型的数据，它的生命周期与线程绑定，并非函数的生命周期，例如：本例中的变量<code>tmpSum</code>。</p>
<p><strong>使用线程本地数据</strong></p>
<p>线程本地数据属于创建它的线程，其只在需要时被创建，非常适合于本地求和。</p>
<pre><code class="language-c++">// threadLocalSummation.cpp

#include &lt;atomic&gt;
#include&lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

constexpr long long size = 100000000;

constexpr long long fir = 25000000;
constexpr long long sec = 50000000;
constexpr long long thi = 75000000;
constexpr long long fou = 100000000;

thread_local unsigned long long tmpSum = 0;

void sumUp(std::atomic&lt;unsigned long long&gt;&amp; sum, const std::vector&lt;int&gt;&amp; val,
  unsigned long long beg, unsigned long long end) {
  for (auto i = beg; i &lt; end; ++i) {
    tmpSum += val[i];
  }
  sum.fetch_add(tmpSum, std::memory_order_relaxed);
}

int main() {

  std::cout &lt;&lt; std::endl;

  std::vector&lt;int&gt; randValues;
  randValues.reserve(size);

  std::mt19937 engine;
  std::uniform_int_distribution&lt;&gt; uniformDist(1, 10);
  for (long long i = 0; i &lt; size; ++i)
    randValues.push_back(uniformDist(engine));

  std::atomic&lt;unsigned long long&gt; sum{};
  const auto sta = std::chrono::steady_clock::now();

  std::thread t1(sumUp, std::ref(sum), std::ref(randValues), 0, fir);
  std::thread t2(sumUp, std::ref(sum), std::ref(randValues), fir, sec);
  std::thread t3(sumUp, std::ref(sum), std::ref(randValues), sec, thi);
  std::thread t4(sumUp, std::ref(sum), std::ref(randValues), thi, fou);

  t1.join();
  t2.join();
  t3.join();
  t4.join();

  std::chrono::duration&lt;double&gt; dur = 
    std::chrono::steady_clock::now() - sta;

  std::cout &lt;&lt; &quot;Time for addition &quot; &lt;&lt; dur.count()
    &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; sum &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>第18行中声明了线程本地变量<code>tmpSum</code>，并在第23和25行中使用它进行加和。</p>
<p>下面是使用本地变量加和的性能数据：</p>
<p><img src="../../../images/detail/Case-Studies/27.png" alt="" /></p>
<p>最后，来看下如何使用任务(task)完成这项工作。</p>
<p><strong>使用任务</strong></p>
<p>使用任务，我们可以使用隐式同步完成整个工作。每个部分求和在单独的线程中执行，最后在主线程中进行求和。</p>
<p>代码如下：</p>
<pre><code class="language-c++">// tasksSummation.cpp

#include&lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

constexpr long long size = 100000000;

constexpr long long fir = 25000000;
constexpr long long sec = 50000000;
constexpr long long thi = 75000000;
constexpr long long fou = 100000000;

void sumUp(std::promise&lt;unsigned long long&gt;&amp;&amp; prom, const std::vector&lt;int&gt;&amp; val,
  unsigned long long beg, unsigned long long end) {
  unsigned long long sum = {};
  for (auto i = beg; i &lt; end; ++i) {
    sum += val[i];
  }
  prom.set_value(sum);
}

int main() {

  std::cout &lt;&lt; std::endl;

  std::vector&lt;int&gt; randValues;
  randValues.reserve(size);

  std::mt19937 engine;
  std::uniform_int_distribution&lt;&gt; uniformDist(1, 10);
  for (long long i = 0; i &lt; size; ++i)
    randValues.push_back(uniformDist(engine));

  std::promise&lt;unsigned long long&gt; prom1;
  std::promise&lt;unsigned long long&gt; prom2;
  std::promise&lt;unsigned long long&gt; prom3;
  std::promise&lt;unsigned long long&gt; prom4;

  auto fut1 = prom1.get_future();
  auto fut2 = prom2.get_future();
  auto fut3 = prom3.get_future();
  auto fut4 = prom4.get_future();

  const auto sta = std::chrono::steady_clock::now();

  std::thread t1(sumUp, std::move(prom1), std::ref(randValues), 0, fir);
  std::thread t2(sumUp, std::move(prom2), std::ref(randValues), fir, sec);
  std::thread t3(sumUp, std::move(prom3), std::ref(randValues), sec, thi);
  std::thread t4(sumUp, std::move(prom4), std::ref(randValues), thi, fou);

  auto sum = fut1.get() + fut2.get() + fut3.get() + fut4.get();

  std::chrono::duration&lt;double&gt; dur = std::chrono::steady_clock::now() - sta;
  std::cout &lt;&lt; &quot;Time for addition &quot; &lt;&lt; dur.count()
    &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; sum &lt;&lt; std::endl;

  t1.join();
  t2.join();
  t3.join();
  t4.join();

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>第39 - 47行定义了四个promise和future。第51 - 54行中，每个promise都被移动到线程中。promise只能移动，不能复制。<code>sumUp</code>的第一个参数使用右值引用的promise。future在第56行使用阻塞的<code>get</code>获取求和结果。</p>
<p><img src="../../../images/detail/Case-Studies/28.png" alt="" /></p>
<p><strong>所有线程本地求和场景的总结</strong></p>
<p>无论是使用局部变量，任务来部分求和，还是各种同步原语(如原子)，性能上好像没有太大的区别，只有线程本地数据似乎让程序变慢了一些。这个观察结果适用于Linux和Windows，不要对Linux相对于Windows的更高性能感到惊讶。别忘了，Linux的电脑上有4个核，而Windows笔记本电脑只有2个核。</p>
<table><thead><tr><th>操作系统(编译器)</th><th align="center"><code>std::lock_guard</code></th><th align="center">使用顺序一致语义的原子变量</th><th align="center">使用自由语义的原子变量</th><th>线程本地数据</th><th>任务</th></tr></thead><tbody>
<tr><td>Linux(GCC)</td><td align="center">0.03</td><td align="center">0.03</td><td align="center">0.03</td><td>0.04</td><td>0.03</td></tr>
<tr><td>Windows(cl.exe)</td><td align="center">0.10</td><td align="center">0.10</td><td align="center">0.10</td><td>0.20</td><td>0.10</td></tr>
</tbody></table>
<p>多线程的本地求和的速度，大约是单线程求和的两倍。因为线程之间几乎不需要同步，所以在最优的情况下，我认为性能会提高四倍。背后的根本原因是什么？</p>
<h2 id="总结求向量元素的加和"><a class="header" href="#总结求向量元素的加和">总结：求向量元素的加和</a></h2>
<p><strong>单线程</strong></p>
<p>基于for循环和STL算法<code>std::accumulate</code>的性能差不多。优化版本中，编译器会使用向量化的<a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a>指令(SSE或AVX)用于求和。因此，循环计数器增加了4(SSE)或8(AVX)。</p>
<p><strong>使用共享变量多线程求和</strong></p>
<p>使用共享变量作为求和变量，可以说明了一点：同步操作是代价是非常昂贵的，应该尽可能避免。虽然我使用了原子变量，甚至打破了顺序一致性，但这四个线程比一个线程还要慢100倍。从性能角度考虑，要尽可能减少同步。</p>
<p><strong>线程本地求和</strong></p>
<p>线程本地求和仅比单线程for循环或<code>std::accumulate</code>快两倍，即使四个线程都可以独立工作，这种情况仍然存在。这也让我很惊讶，因为我原以为会有四倍的性能提升。更让我惊讶的是，电脑的四个核心并没有充分利用。</p>
<p><img src="../../../images/detail/Case-Studies/29.png" alt="" /></p>
<p>没有充分利用的原因也很简单，CPU无法快速地从内存中获取数据。程序执行是有<a href="https://en.wikipedia.org/wiki/Memory_bound_function">内存限制</a>的，或者说内存延迟了CPU核的计算速度。下图展示了计算时的瓶颈内存。</p>
<p><img src="../../../images/detail/Case-Studies/30.png" alt="" /></p>
<p><a href="https://en.wikipedia.org/wiki/Roofline_model">Roofline模型</a>是一种直观的性能模型，可对运行在多核或多核体系结构上的应用程序进行性能评估。该模型依赖于体系结构的峰值性能、峰值带宽和计算密度。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../../content/The-Details/Case-Studies/4.0-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../../content/The-Details/Case-Studies/4.2-chinese.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../../content/The-Details/Case-Studies/4.0-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../../content/The-Details/Case-Studies/4.2-chinese.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
