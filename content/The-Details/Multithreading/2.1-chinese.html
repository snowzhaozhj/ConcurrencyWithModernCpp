<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>线程 - ConcurrencyWithModernCpp</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../../favicon.svg">
                        <link rel="shortcut icon" href="../../../favicon.png">
                <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
                <link rel="stylesheet" href="../../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../content/Reader-Testimonials.html"><strong aria-hidden="true">1.</strong> 读者推荐</a></li><li class="chapter-item expanded "><a href="../../../content/Source-Code.html"><strong aria-hidden="true">2.</strong> 代码说明</a></li><li class="chapter-item expanded "><a href="../../../content/How-you-should-read-the-book.html"><strong aria-hidden="true">3.</strong> 如何阅读</a></li><li class="chapter-item expanded "><a href="../../../content/History-Quick-Overview.html"><strong aria-hidden="true">4.</strong> C++并发历史概述</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 详细介绍</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.0-chinese.html"><strong aria-hidden="true">5.1.</strong> 内存模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.1-chinese.html"><strong aria-hidden="true">5.1.1.</strong> 内存模型的基础知识</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.2-chinese.html"><strong aria-hidden="true">5.1.2.</strong> 编程协议</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.3-chinese.html"><strong aria-hidden="true">5.1.3.</strong> 原子操作</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.4-chinese.html"><strong aria-hidden="true">5.1.4.</strong> 同步和顺序</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.5-chinese.html"><strong aria-hidden="true">5.1.5.</strong> 栅栏(Fences)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.0-chinese.html"><strong aria-hidden="true">5.2.</strong> 多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.1-chinese.html" class="active"><strong aria-hidden="true">5.2.1.</strong> 线程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.2-chinese.html"><strong aria-hidden="true">5.2.2.</strong> 共享数据</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.3-chinese.html"><strong aria-hidden="true">5.2.3.</strong> 线程-本地数据</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.4-chinese.html"><strong aria-hidden="true">5.2.4.</strong> 条件变量</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.5-chinese.html"><strong aria-hidden="true">5.2.5.</strong> 任务</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.0-chinese.html"><strong aria-hidden="true">5.3.</strong> 标准库的并行算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.1-chinese.html"><strong aria-hidden="true">5.3.1.</strong> 执行策略</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.2-chinese.html"><strong aria-hidden="true">5.3.2.</strong> 算法</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.3-chinese.html"><strong aria-hidden="true">5.3.3.</strong> 新算法</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.4-chinese.html"><strong aria-hidden="true">5.3.4.</strong> 性能概况</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.0-chinese.html"><strong aria-hidden="true">5.4.</strong> 案例研究</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.1-chinese.html"><strong aria-hidden="true">5.4.1.</strong> 求向量元素的加和</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.2-chinese.html"><strong aria-hidden="true">5.4.2.</strong> 单例模式：线程安全的初始化</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.3-chinese.html"><strong aria-hidden="true">5.4.3.</strong> 使用CppMem进行优化</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.4-chinese.html"><strong aria-hidden="true">5.4.4.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.0-chinese.html"><strong aria-hidden="true">5.5.</strong> C++20/23的特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.1-chinese.html"><strong aria-hidden="true">5.5.1.</strong> 关于执行</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.2-chinese.html"><strong aria-hidden="true">5.5.2.</strong> 可协作中断的线程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.3-chinese.html"><strong aria-hidden="true">5.5.3.</strong> 原子智能指针</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.4-chinese.html"><strong aria-hidden="true">5.5.4.</strong> 扩展特性</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.5-chinese.html"><strong aria-hidden="true">5.5.5.</strong> 门闩和栅栏</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.6-chinese.html"><strong aria-hidden="true">5.5.6.</strong> 协程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.7-chinese.html"><strong aria-hidden="true">5.5.7.</strong> 事务性内存</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.8-chinese.html"><strong aria-hidden="true">5.5.8.</strong> 任务块</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.0-chinese.html"><strong aria-hidden="true">6.1.</strong> 模式和最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.1-chinese.html"><strong aria-hidden="true">6.1.1.</strong> 相关历史</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.2-chinese.html"><strong aria-hidden="true">6.1.2.</strong> 价值所在</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.3-chinese.html"><strong aria-hidden="true">6.1.3.</strong> 模式与最佳实践</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.4-chinese.html"><strong aria-hidden="true">6.1.4.</strong> 反模式</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.0-chinese.html"><strong aria-hidden="true">6.2.</strong> 同步模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.1-chinese.html"><strong aria-hidden="true">6.2.1.</strong> 处理共享</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.2-chinese.html"><strong aria-hidden="true">6.2.2.</strong> 处理突变</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.0-chinese.html"><strong aria-hidden="true">6.3.</strong> 并发架构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.1-chinese.html"><strong aria-hidden="true">6.3.1.</strong> 活动对象</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.2-chinese.html"><strong aria-hidden="true">6.3.2.</strong> 监控对象</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.3-chinese.html"><strong aria-hidden="true">6.3.3.</strong> 半同步/半异步</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.0-chinese.html"><strong aria-hidden="true">6.4.</strong> 最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.1-chinese.html"><strong aria-hidden="true">6.4.1.</strong> 通常情况</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.2-chinese.html"><strong aria-hidden="true">6.4.2.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.3-chinese.html"><strong aria-hidden="true">6.4.3.</strong> 内存模型</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 数据结构</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Data-Structures/10.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 有锁结构</a></li><li class="chapter-item expanded "><a href="../../../content/Data-Structures/10.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 无锁结构</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 更多信息</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.1-chinese.html"><strong aria-hidden="true">8.1.</strong> 挑战</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 时间库</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.3-chinese.html"><strong aria-hidden="true">8.3.</strong> CppMem-概述</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 术语表</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">ConcurrencyWithModernCpp</h1>

                    <div class="right-buttons">
                                                <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>#线程</p>
<p>要用C++标准库启动一个线程，就必须包含<code>&lt;thread&gt;</code>头文件。</p>
<h2 id="创建线程"><a class="header" href="#创建线程">创建线程</a></h2>
<p>线程<code>std::thread</code>对象表示一个可执行单元。当工作包是可调用单元时，工作包可以立即启动。线程对象是不可复制构造或复制赋值的，但可移动构造或移动赋值。</p>
<p>可调用单元是行为类似于函数。当然，它可以是一个函数，也可以是一个函数对象，或者一个Lambda表达式。通常忽略可调用单元的返回值。</p>
<p>介绍完理论知识之后，我们来动手写个小例子。</p>
<pre><code class="language-c++">// createThread.cpp

#include &lt;iostream&gt;
#include &lt;thread&gt;

void helloFunction() {
  std::cout &lt;&lt; &quot;Hello from a function.&quot; &lt;&lt; std::endl;
}

class HelloFUncitonObject {
public:
  void operator()()const {
    std::cout &lt;&lt; &quot;Hello from a function object.&quot; &lt;&lt; std::endl;
  }
};

int main() {
  
  std::cout &lt;&lt; std::endl;

  std::thread t1(helloFunction);
  HelloFUncitonObject helloFunctionObject;
  std::thread t2(helloFunctionObject);

  std::thread t3([] {std::cout &lt;&lt; &quot;Hello from a lambda.&quot; &lt;&lt; std::endl; });

  t1.join();
  t2.join();
  t3.join();

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>三个线程(<code>t1</code>、<code>t2</code>和<code>t3</code>)都会将信息写入控制台。线程<code>t2</code>的工作包是一个函数对象(第10 - 15行)，线程<code>t3</code>的工作包是一个Lambda函数(第26行)。第28 - 30行，主线程在等待子线程完成工作。</p>
<p>看一下输出。</p>
<p><img src="../../../images/detail/multithreading/2.png" alt="" /></p>
<p>三个线程以任意顺序执行，这三个输出操作也可以交错。</p>
<p>线程的创建者(例子中是主线程)负责管理线程的生命周期，所以让我们来了解一下线程的生命周期。</p>
<p>##线程的生命周期</p>
<p>父母需要照顾自己的孩子，这个简单的原则对线程的生命周期非常重要。下面的程序(子线程最后没有汇入)，用来显示线程ID。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;

int main() {
  
  std::thread t([] {std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; });
  
}
</code></pre>
<p>程序出现了错误，不过依旧打印了线程的ID。</p>
<p><img src="../../../images/detail/multithreading/3.png" alt="" /></p>
<p>那是什么原因引起的异常呢？</p>
<p><strong>汇入和分离</strong></p>
<p>线程<code>t</code>的生命周期终止于可调用单元执行结束，而创建者有两个选择：</p>
<ol>
<li>等待线程完成: <code>t.join()</code></li>
<li>与创建线程解除关系:<code>t.detach() </code></li>
</ol>
<p>当后续代码依赖于线程中调用单元的计算结果时，需要使用<code>t.join()</code>。<code>t.detach()</code>允许线程与创建线程分离执行，所以分离线程的生命周期与可执行文件的运行周期相关。通常，服务器上长时间运行的后台服务，会使用分离线程。</p>
<p>如果<code>t.join()</code>和<code>t.detach()</code>都没有执行，那么线程<code>t</code>是可汇入的。可汇入线程的析构函数会抛出<code>std::terminate</code>异常，这也就是threadWithoutJoin.cpp程序产生异常的原因。如果在线程上多次调用<code>t.join()</code>或<code>t.detach()</code>，则会产生<code>std::system_error</code>异常。</p>
<p>解决问题的方法很简单：使用<code>t.join()</code>。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;

int main() {
  
  std::thread t([] {std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; });
  
  t.join();
  
}
</code></pre>
<p>现在就能得到满意的输出了。</p>
<p><img src="../../../images/detail/multithreading/4.png" alt="" /></p>
<p>线程ID是<code>std::thread</code>唯一的标识符。</p>
<blockquote>
<p><strong>分离线程的挑战</strong></p>
<p>当然，可以在最后一个程序中使用<code>t.detach()</code>代替<code>t.join()</code>。这样，线程<code>t</code>不能汇入了；因此，它的析构函数没有调用<code>std::terminate</code>函数。但现在有另一个问题：未定义行为。主程序可能在线程<code>t</code>前结束，所以由于主线程的生存期太短，无法显示ID。详细信息，可以参考变量的生存期。</p>
</blockquote>
<blockquote>
<p><strong>Anthony Williams提出的scoped_thread</strong></p>
<p>如果手动处理线程的生命周期可能有些麻烦，可以在包装器中封装<code>std::thread</code>。如果线程仍然是可汇入的，这个类应该在其析构函数中自动调用<code>t.join()</code>，也可以反过来调用<code>t.detach()</code>，但分离处理也有问题。</p>
<p>Anthony Williams提出了这样一个类，并在他的优秀著作<a href="https://www.manning.com/books/c-plus-plus-concurrency-in-action">《C++ Concurrency in Action》</a>中介绍了它。他将包装器称为<code>scoped_thread</code>。<code>scoped_thread</code>在构造函数中获取了线程对象，并检查线程对象是否可汇入。如果传递给构造函数的线程对象不可汇入，则不需要<code>scoped_thread</code>。如果线程对象可汇入，则析构函数调用<code>t.join()</code>。因为，复制构造函数和复制赋值操作符被声明为<code>delete</code>，所以<code>scoped_thread</code>的实例不能复制或赋值。</p>
<pre><code class="language-c++">// scoped_thread.cpp

#include &lt;thread&gt;
#include &lt;utility&gt;

class scoped_thread{
std::thread t;
public:
  explicit scoped_thread(std::thread t_): t(std::move(t_)){
  	if (!t.joinable()) throw std::logic_error(&quot;No thread&quot;);
  }
  ~scoped_thread(){
  	t.join();
  }
  scoped_thread(scoped_thread&amp;)= delete;
  scoped_thread&amp; operator=(scoped_thread const &amp;)= delete;
};
</code></pre>
</blockquote>
<h2 id="线程参数"><a class="header" href="#线程参数">线程参数</a></h2>
<p>和函数一样，线程可以通过复制、移动或引用来获取参数。<code>std::thread</code>是一个<a href="http://en.cppreference.com/w/cpp/language/parameter_pack">可变参数模板</a>，可以传入任意数量的参数。</p>
<p>线程通过引用的方式获取数据的情况，必须非常小心参数的生命周期和数据的共享方式。</p>
<h3 id="复制或引用"><a class="header" href="#复制或引用">复制或引用</a></h3>
<p>我们来看一个代码段。</p>
<pre><code class="language-c++">std::string s{&quot;C++11&quot;}

std::thread t1([=]{ std::cout &lt;&lt; s &lt;&lt; std::endl; });
t1.join();

std::thread t2([&amp;]{ std::cout &lt;&lt; s &lt;&lt; std::endl; });
t2.detach();
</code></pre>
<p>线程<code>t1</code>通过复制的方式获取参数，线程<code>t2</code>通过引用的方式获取参数。</p>
<blockquote>
<p><strong>线程的“引用”参数</strong></p>
<p>实际上，我骗了你。线程<code>t2</code>不是通过引用获取其参数，而是Lambda表达式通过引用捕获的参数。如果需要引用将参数传递给线程，则必须将其包装在<a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper">引用包装器</a>中，使用<a href="http://en.cppreference.com/w/cpp/utility/functional/ref">std::ref</a>就能完成这项任务。<code>std::ref</code>在<code>&lt;functional&gt;</code>头文件中定义。</p>
<pre><code class="language-c++">&lt;functional&gt;
...
void transferMoney(int amount, Account&amp; from, Account&amp; to){
...
}
...
std::thread thr1(transferMoney, 50, std::ref(account1), std::ref(account2));
</code></pre>
<p>线程<code>thr1</code>执行<code>transferMoney</code>函数。<code>transferMoney</code>的参数是使用引用的方式传递，所以线程<code>thr1</code>通过引用获取<code>account1</code>和<code>account2</code>。</p>
</blockquote>
<p>这几行代码中隐藏着什么问题呢？线程<code>t2</code>通过引用获取其字符串<code>s</code>，然后从其创建者的生命周期中分离。字符串<code>s</code>与创建者的生存期周期绑定，全局对象<code>std::cout</code>与主线程的生存周期绑定。因此，<code>std::cout</code>的生存周期可能比线程<code>t2</code>的生存周期短。现在，我们已经置身于未定义行为中了。</p>
<p>不相信？来看看未定义行为是什么样的。</p>
<pre><code class="language-c++">// threadArguments.cpp

#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

class Sleeper {
public:
  Sleeper(int&amp; i_) :i{ i_ } {};
  void operator()(int k) {
    for (unsigned int j = 0; j &lt;= 5; ++j) {
      std::this_thread::sleep_for(std::chrono::microseconds(100));
      i += k;
    }
    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
  }
private:
  int&amp; i;
};


int main() {

  std::cout &lt;&lt; std::endl;

  int valSleepr = 1000;
  std::thread t(Sleeper(valSleepr), 5);
  t.detach();
  std::cout &lt;&lt; &quot;valSleeper = &quot; &lt;&lt; valSleepr &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>问题在于：<code>valSleeper</code>在第29行时值是多少？<code>valSleeper</code>是一个全局变量。线程<code>t</code>获得一个函数对象，该函数对象的实参为变量<code>valSleeper</code>和数字5(第27行)，而线程通过引用获得<code>valSleeper</code>(第9行)，并与主线程(第28行)分离。接下来，执行函数对象的调用操作符(第10 - 16行)，它从0计数到5，在每100毫秒的中休眠，将<code>k</code>加到<code>i</code>上。最后，屏幕上显示它的id。<a href="https://de.wikipedia.org/wiki/Liste_gefl%C3%BCgelter_Worte/N#Nach_Adam_Riese">Nach Adam Riese</a> (德国成语：真是精准的计算呀！)，期望的结果应该是1000 + 6 * 5 = 1030。</p>
<p>然而，发生了什么？结果为什么完全不对？</p>
<p><img src="../../../images/detail/multithreading/5.png" alt="" /></p>
<p>这个输出有两个奇怪的地方：首先，<code>valSleeper</code>是1000；其次，ID没有显示。</p>
<p>这段程序至少有两个错误：</p>
<ol>
<li><code>valSleeper</code>是线程共享的。这会导致数据竞争，因为线程可能同时读写<code>valSleeper</code>。</li>
<li>主线程的生命周期很可能在子线程执行计算，或将其ID写入<code>std::cout</code>之前结束。</li>
</ol>
<p>这两个问题都是构成竞态条件，因为程序的结果取决于操作的交错。构成竞态的条件也是导致数据竞争的原因。</p>
<p>解决数据竞争也非常容易：使用锁或原子保护<code>valSleeper</code>。为了解决<code>valSleeper</code>和<code>std::cout</code>的生命周期问题，必须汇入线程而不是分离它。</p>
<p>修改后的主函数体。</p>
<pre><code class="language-c++">int main(){
  
  std::cout &lt;&lt; std::endl;
  
  int valSleeper= 1000;
  std::thread t(Sleeper(valSleeper),5);
  t.join();
  std::cout &lt;&lt; &quot;valSleeper = &quot; &lt;&lt; valSleeper &lt;&lt; std::endl;
  
  std::cout &lt;&lt; std::endl;
  
}
</code></pre>
<p>现在，我们得到了正确的结果。当然，执行速度会变慢。</p>
<p><img src="../../../images/detail/multithreading/6.png" alt="" /></p>
<p>为了更完整的了解<code>std::thread</code>，接下来了解其成员函数。</p>
<p>###成员函数</p>
<p>下面是<code>std::thread</code>的接口，在一个简洁的表中。更多详情请访问<a href="http://de.cppreference.com/w/cpp/thread/thread">cppreference.com</a>。</p>
<table><thead><tr><th align="center">函数名称</th><th align="center">描述</th></tr></thead><tbody>
<tr><td align="center"><code>t.join()</code></td><td align="center">等待，直到线程t完成</td></tr>
<tr><td align="center"><code>t.detach()</code></td><td align="center">独立于创建者执行创建的线程t</td></tr>
<tr><td align="center"><code>t.joinable()</code></td><td align="center">如果线程t可以汇入，则返回true</td></tr>
<tr><td align="center"><code>t.get_id()</code>和<code>std::this_thread::get_id()</code></td><td align="center">返回线程的ID</td></tr>
<tr><td align="center"><code>std::thread::hardware_concurrency()</code></td><td align="center">返回可以并发运行的线程数</td></tr>
<tr><td align="center"><code>std::this_thread::sleep_until(absTime)</code></td><td align="center">将线程t置为睡眠状态，直到absTime时间点为止</td></tr>
<tr><td align="center"><code>std::this_thread::sleep_for(relTime)</code></td><td align="center">将线程t置为睡眠状态，直到休眠了relTime为止</td></tr>
<tr><td align="center"><code>std::this_thread::yield()</code></td><td align="center">允许系统运行另一个线程</td></tr>
<tr><td align="center"><code>t.swap(t2)</code>和<code>std::swap(t1, t2)</code></td><td align="center">交换线程对象</td></tr>
</tbody></table>
<p>静态函数<code>std::thread::hardware_concurrency</code>返回实现支持的并发线程数量，如果运行时无法确定数量，则返回0(这是根据C++标准编写的)。<code>sleep_until</code>和<code>sleep_for</code>操作需要一个时间点或持续时间作为参数。</p>
<blockquote>
<p><strong>访问特定系统的实现</strong></p>
<p>线程接口是底层实现的包装器，可以使用<code>native_handle</code>来访问(特定于系统的实现)。这个底层实现的句柄可用于线程、互斥对象和条件变量。</p>
</blockquote>
<p>作为对本小节的总结，下面是在实践中提到的一些方法。</p>
<pre><code class="language-c++">// threadMethods.cpp

#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

int main() {

  cout &lt;&lt; boolalpha &lt;&lt; endl;

  cout &lt;&lt; &quot;hardware_concurrency() = &quot; &lt;&lt; thread::hardware_concurrency() &lt;&lt; endl;

  thread t1([] {cout &lt;&lt; &quot;t1 with id = &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl; });
  thread t2([] {cout &lt;&lt; &quot;t2 with id = &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl; });

  cout &lt;&lt; endl;

  cout &lt;&lt; &quot;FROM MAIN: id of t1 &quot; &lt;&lt; t1.get_id() &lt;&lt; endl;
  cout &lt;&lt; &quot;FROM MAIN: id of t2 &quot; &lt;&lt; t2.get_id() &lt;&lt; endl;

  cout &lt;&lt; endl;
  swap(t1, t2);

  cout &lt;&lt; &quot;FROM MAIN: id of t1 &quot; &lt;&lt; t1.get_id() &lt;&lt; endl;
  cout &lt;&lt; &quot;FROM MAIN: id of t2 &quot; &lt;&lt; t2.get_id() &lt;&lt; endl;

  cout &lt;&lt; endl;

  cout &lt;&lt; &quot;FROM MAIN: id of main= &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;

  cout &lt;&lt; endl;

  cout &lt;&lt; &quot;t1.joinable(): &quot; &lt;&lt; t1.joinable() &lt;&lt; endl;

  cout &lt;&lt; endl;

  t1.join();
  t2.join();

  cout &lt;&lt; endl;

  cout &lt;&lt; &quot;t1.joinable(): &quot; &lt;&lt; t1.joinable() &lt;&lt; endl;

  cout &lt;&lt; endl;

}
</code></pre>
<p>与输出相结合来看，应该很容易理解。</p>
<p><img src="../../../images/detail/multithreading/7.png" alt="" /></p>
<p>结果可能看起来有点奇怪，线程<code>t1</code>和<code>t2</code>(第14行和第15行)在不同时间点上运行。无法确定每个线程何时运行，只能确定在第38和39行<code>t1.join()</code>和<code>t2.join()</code>语句之前两个线程是肯定运行了的。</p>
<p>线程共享的可变(非const)变量越多，程序的风险就越大。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../../content/The-Details/Multithreading/2.0-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../../content/The-Details/Multithreading/2.2-chinese.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../../content/The-Details/Multithreading/2.0-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../../content/The-Details/Multithreading/2.2-chinese.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
