<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>共享数据 - ConcurrencyWithModernCpp</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../../favicon.svg">
                        <link rel="shortcut icon" href="../../../favicon.png">
                <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
                <link rel="stylesheet" href="../../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../content/Reader-Testimonials.html"><strong aria-hidden="true">1.</strong> 读者推荐</a></li><li class="chapter-item expanded "><a href="../../../content/Source-Code.html"><strong aria-hidden="true">2.</strong> 代码说明</a></li><li class="chapter-item expanded "><a href="../../../content/How-you-should-read-the-book.html"><strong aria-hidden="true">3.</strong> 如何阅读</a></li><li class="chapter-item expanded "><a href="../../../content/History-Quick-Overview.html"><strong aria-hidden="true">4.</strong> C++并发历史概述</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 详细介绍</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.0-chinese.html"><strong aria-hidden="true">5.1.</strong> 内存模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.1-chinese.html"><strong aria-hidden="true">5.1.1.</strong> 内存模型的基础知识</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.2-chinese.html"><strong aria-hidden="true">5.1.2.</strong> 编程协议</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.3-chinese.html"><strong aria-hidden="true">5.1.3.</strong> 原子操作</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.4-chinese.html"><strong aria-hidden="true">5.1.4.</strong> 同步和顺序</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Memory-Model/1.5-chinese.html"><strong aria-hidden="true">5.1.5.</strong> 栅栏(Fences)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.0-chinese.html"><strong aria-hidden="true">5.2.</strong> 多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.1-chinese.html"><strong aria-hidden="true">5.2.1.</strong> 线程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.2-chinese.html" class="active"><strong aria-hidden="true">5.2.2.</strong> 共享数据</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.3-chinese.html"><strong aria-hidden="true">5.2.3.</strong> 线程-本地数据</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.4-chinese.html"><strong aria-hidden="true">5.2.4.</strong> 条件变量</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Multithreading/2.5-chinese.html"><strong aria-hidden="true">5.2.5.</strong> 任务</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.0-chinese.html"><strong aria-hidden="true">5.3.</strong> 标准库的并行算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.1-chinese.html"><strong aria-hidden="true">5.3.1.</strong> 执行策略</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.2-chinese.html"><strong aria-hidden="true">5.3.2.</strong> 算法</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.3-chinese.html"><strong aria-hidden="true">5.3.3.</strong> 新算法</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.4-chinese.html"><strong aria-hidden="true">5.3.4.</strong> 性能概况</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.0-chinese.html"><strong aria-hidden="true">5.4.</strong> 案例研究</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.1-chinese.html"><strong aria-hidden="true">5.4.1.</strong> 求向量元素的加和</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.2-chinese.html"><strong aria-hidden="true">5.4.2.</strong> 单例模式：线程安全的初始化</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.3-chinese.html"><strong aria-hidden="true">5.4.3.</strong> 使用CppMem进行优化</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/Case-Studies/4.4-chinese.html"><strong aria-hidden="true">5.4.4.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.0-chinese.html"><strong aria-hidden="true">5.5.</strong> C++20/23的特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.1-chinese.html"><strong aria-hidden="true">5.5.1.</strong> 关于执行</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.2-chinese.html"><strong aria-hidden="true">5.5.2.</strong> 可协作中断的线程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.3-chinese.html"><strong aria-hidden="true">5.5.3.</strong> 原子智能指针</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.4-chinese.html"><strong aria-hidden="true">5.5.4.</strong> 扩展特性</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.5-chinese.html"><strong aria-hidden="true">5.5.5.</strong> 门闩和栅栏</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.6-chinese.html"><strong aria-hidden="true">5.5.6.</strong> 协程</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.7-chinese.html"><strong aria-hidden="true">5.5.7.</strong> 事务性内存</a></li><li class="chapter-item expanded "><a href="../../../content/The-Details/The-Future-CPP-20-23/5.8-chinese.html"><strong aria-hidden="true">5.5.8.</strong> 任务块</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.0-chinese.html"><strong aria-hidden="true">6.1.</strong> 模式和最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.1-chinese.html"><strong aria-hidden="true">6.1.1.</strong> 相关历史</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.2-chinese.html"><strong aria-hidden="true">6.1.2.</strong> 价值所在</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.3-chinese.html"><strong aria-hidden="true">6.1.3.</strong> 模式与最佳实践</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Patterns-and-Best-Practices/6.4-chinese.html"><strong aria-hidden="true">6.1.4.</strong> 反模式</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.0-chinese.html"><strong aria-hidden="true">6.2.</strong> 同步模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.1-chinese.html"><strong aria-hidden="true">6.2.1.</strong> 处理共享</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Synchronisation-Patterns/7.2-chinese.html"><strong aria-hidden="true">6.2.2.</strong> 处理突变</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.0-chinese.html"><strong aria-hidden="true">6.3.</strong> 并发架构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.1-chinese.html"><strong aria-hidden="true">6.3.1.</strong> 活动对象</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.2-chinese.html"><strong aria-hidden="true">6.3.2.</strong> 监控对象</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Concurrent-Architecture/8.3-chinese.html"><strong aria-hidden="true">6.3.3.</strong> 半同步/半异步</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.0-chinese.html"><strong aria-hidden="true">6.4.</strong> 最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.1-chinese.html"><strong aria-hidden="true">6.4.1.</strong> 通常情况</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.2-chinese.html"><strong aria-hidden="true">6.4.2.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="../../../content/Pattrns/Best-Practices/9.3-chinese.html"><strong aria-hidden="true">6.4.3.</strong> 内存模型</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 数据结构</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Data-Structures/10.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 有锁结构</a></li><li class="chapter-item expanded "><a href="../../../content/Data-Structures/10.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 无锁结构</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 更多信息</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.1-chinese.html"><strong aria-hidden="true">8.1.</strong> 挑战</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 时间库</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.3-chinese.html"><strong aria-hidden="true">8.3.</strong> CppMem-概述</a></li><li class="chapter-item expanded "><a href="../../../content/Further-Information/11.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 术语表</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">ConcurrencyWithModernCpp</h1>

                    <div class="right-buttons">
                                                <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>#共享数据</p>
<p>为了更清楚地说明这一点，就需要考虑共享数据的同步问题，因为数据竞争很容易在共享数据上发生。如果并发地对数据进行非同步读写访问，则会产生未定义行为。</p>
<p>验证并发、未同步的读写操作的最简单方法，就是向<code>std::cout</code>写入一些内容。</p>
<p>让我们来看一下，使用不同步的方式进行<code>std::cout</code>打印输出。</p>
<pre><code class="language-c++">// coutUnsynchronised.cpp

#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

class Worker {
public:
  Worker(std::string n) :name(n) {}
  void operator()() {
    for (int i = 1; i &lt;= 3; ++i) {
      // begin work
      std::this_thread::sleep_for(std::chrono::microseconds(200));
      // end work
      std::cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; &quot;Work &quot; &lt;&lt; i &lt;&lt; &quot; done !!!&quot; &lt;&lt; std::endl;
    }
  }
private:
  std::string name;
};


int main() {
  
  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; &quot;Boss: Let's start working.\n\n&quot;;

  std::thread herb = std::thread(Worker(&quot;Herb&quot;));
  std::thread andrei = std::thread(Worker(&quot; Andrei&quot;));
  std::thread scott = std::thread(Worker(&quot;  Scott&quot;));
  std::thread bjarne = std::thread(Worker(&quot;   Bjarne&quot;));
  std::thread bart = std::thread(Worker(&quot;    Bart&quot;));
  std::thread jenne = std::thread(Worker(&quot;     Jenne&quot;));


  herb.join();
  andrei.join();
  scott.join();
  bjarne.join();
  bart.join();
  jenne.join();

  std::cout &lt;&lt; &quot;\n&quot; &lt;&lt; &quot;Boss: Let's go home.&quot; &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>该程序描述了一个工作流程：老板有六个员工(第29 - 34行)，每个员工必须处理3个工作包，处理每个工作包需要200毫秒(第13行)。当员工完成了他的所有工作包时，他向老板报告(第15行)。当老板收到所有员工的报告，老板就会把员工们送回家(第43行)。</p>
<p>这么简单的工作流程，输出却如此混乱。</p>
<p><img src="../../../images/detail/multithreading/8.png" alt="" /></p>
<p>让输出变清晰的最简单解决方法，就是使用互斥量。</p>
<p>##互斥量</p>
<p>Mutex是互斥(<strong>mut</strong>ual <strong>ex</strong>clusion)的意思，它确保在任何时候只有一个线程可以访问临界区。</p>
<p>通过使用互斥量，工作流程的混乱变的和谐许多。</p>
<pre><code class="language-c++">// coutSynchronised.cpp

#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex coutMutex;

class Worker {
public:
  Worker(std::string n) :name(n) {}
  void operator()() {
    for (int i = 1; i &lt;= 3; ++i) {
      // begin work
      std::this_thread::sleep_for(std::chrono::microseconds(200));
      // end work
      coutMutex.lock();
      std::cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; &quot;Work &quot; &lt;&lt; i &lt;&lt; &quot; done !!!&quot; &lt;&lt; std::endl;
      coutMutex.unlock();
    }
  }
private:
  std::string name;
};


int main() {
  
  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; &quot;Boss: Let's start working.\n\n&quot;;

  std::thread herb = std::thread(Worker(&quot;Herb&quot;));
  std::thread andrei = std::thread(Worker(&quot; Andrei&quot;));
  std::thread scott = std::thread(Worker(&quot;  Scott&quot;));
  std::thread bjarne = std::thread(Worker(&quot;   Bjarne&quot;));
  std::thread bart = std::thread(Worker(&quot;    Bart&quot;));
  std::thread jenne = std::thread(Worker(&quot;     Jenne&quot;));


  herb.join();
  andrei.join();
  scott.join();
  bjarne.join();
  bart.join();
  jenne.join();

  std::cout &lt;&lt; &quot;\n&quot; &lt;&lt; &quot;Boss: Let's go home.&quot; &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>第8行中<code>coutMutex</code>保护了<code>std::cout</code>，第19行中的<code>lock()</code>和第21行中的<code>unlock()</code>调用，确保工作人员不会同时进行报告。</p>
<p><img src="../../../images/detail/multithreading/9.png" alt="" /></p>
<blockquote>
<p><strong>std:: cout是线程安全的</strong></p>
<p>C++11标准中，<code>std::cout</code>不需要额外的保护，每个字符都是原子式书写的。可能会有更多类似示例中的输出语句交织在一起的情况，但这些只是视觉问题，而程序则是定义良好的。所有全局流对象都是线程安全的，并且插入和提取全局流对象(<code>std::cout</code>、<code>std::cin</code>、<code>std::cerr</code>和<code>std::clog</code>)也都是线程安全的。</p>
<p>更正式地说：写入<code>std::cout</code>并不是数据竞争，而是一个竞争条件。这意味着输出内容的情况，完全取决于交错运行的线程。</p>
</blockquote>
<p>C++11有4个不同的互斥量，可以递归地、暂时地锁定，并且不受时间限制。</p>
<table><thead><tr><th align="center">成员函数</th><th align="center">mutex</th><th align="center">recursive_mutex</th><th align="center">timed_mutex</th><th align="center">recursive_timed_mutex</th></tr></thead><tbody>
<tr><td align="center">m.lock</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center">m.try_lock</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center">m.try_lock_for</td><td align="center"></td><td align="center"></td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center">m.try_lock_until</td><td align="center"></td><td align="center"></td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center">m.unlock</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr>
</tbody></table>
<p>递归互斥量允许同一个线程多次锁定互斥锁。互斥量保持锁定状态，直到解锁次数与锁定次数相等。可以锁定互斥量的最大次数默认并未指定，当达到最大值时，会抛出<a href="http://en.cppreference.com/w/cpp/error/system_error">std::system_error</a>异常。</p>
<p>C++14中有<code>std::shared_timed_mutex</code>，C++17中有<code>std::shared_mutex</code>。<code>std::shared_mutex</code>和<code>std::shared_timed_mutex</code>非常相似，使用的锁可以是互斥或共享的。另外，使用<code>std::shared_timed_mutex</code>可以指定时间点或时间段进行锁定。</p>
<table><thead><tr><th align="center">成员函数</th><th align="center">shared_timed_mutex</th><th align="center">shared_mutex</th></tr></thead><tbody>
<tr><td align="center">m.lock</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center">m.try_lock</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center">m.try_lock_for</td><td align="center">yes</td><td align="center"></td></tr>
<tr><td align="center">m.try_lock_until</td><td align="center">yes</td><td align="center"></td></tr>
<tr><td align="center">m.unlock</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center">m.lock_shared</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center">m.try_lock_shared</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center">m.try_lock_shared_for</td><td align="center">yes</td><td align="center"></td></tr>
<tr><td align="center">m.try_lock_shared_until</td><td align="center">yes</td><td align="center"></td></tr>
<tr><td align="center">m.unlock_shared</td><td align="center">yes</td><td align="center">yes</td></tr>
</tbody></table>
<p><code>std::shared_timed_mutex(std::shared_mutex)</code>可以用来实现读写锁，也就可以使用<code>std::shared_timed_mutex(std::shared_mutex)</code>进行独占或共享锁定。如果将<code>std::shared_timed_mutex(std::shared_mutex)</code>放入<code>std::lock_guard</code>或<code>std::unique_lock</code>中，就可实现独占锁；如果将<code>std::shared_timed_mutex(std::shared_lock)</code>放入<code>std::shared_lock</code>中，就可实现共享锁。<code>m.try_lock_for(relTime)</code>和<code>m.try_lock_shared_for(relTime)</code>需要一个时间段；<code>m.try_lock_until(absTime)</code>和<code>m.try_lock_shared_until(absTime)</code>需要一个绝对的时间点。</p>
<p><code>m.try_lock(m.try_lock_shared)</code>尝试锁定互斥量并立即返回。成功时，它返回true，否则返回false。相比之下，<code>m.try_lock_for(m.try_lock_shared_for)</code>和<code>m.try_lock_until(m.try_lock_shared_until)</code>也会尝试上锁，直到超时或完成锁定，这里应该使用稳定时钟来限制时间(稳定的时钟是不能调整的)。</p>
<p>不应该直接使用互斥量，应该将互斥量放入锁中，下面解释下原因。</p>
<h3 id="互斥量的问题"><a class="header" href="#互斥量的问题">互斥量的问题</a></h3>
<p>互斥量的问题可以归结为一个：死锁。</p>
<blockquote>
<p><strong>死锁</strong></p>
<p>两个或两个以上的个线程处于阻塞状态，并且每个线程在释放之前都要等待其他线程的释放。</p>
</blockquote>
<p>结果就是程序完全静止。试图获取资源的线程，通常会永久的阻塞程序。形成这种困局很简单，有兴趣了解一下吗?</p>
<h3 id="异常和未知代码"><a class="header" href="#异常和未知代码">异常和未知代码</a></h3>
<p>下面的代码段有很多问题。</p>
<pre><code class="language-c++">std::mutex m;
m.lock();
sharedVariable = getVar();
m.unlock();
</code></pre>
<p>问题如下：</p>
<ol>
<li>如果函数<code>getVar()</code>抛出异常，则互斥量<code>m</code>不会被释放。</li>
<li>永远不要在持有锁的时候调用函数。因为<code>m</code>不是递归互斥量，如果函数<code>getVar</code>试图锁定互斥量<code>m</code>，则程序具有未定义的行为。大多数情况下，未定义行为会导致死锁。</li>
<li>避免在持有锁时调用函数。可能这个函数来自一个库，但当这个函数发生改变，就有陷入僵局的可能。</li>
</ol>
<p>程序需要的锁越多，程序的风险就越高(非线性)。</p>
<h3 id="不同顺序锁定的互斥锁"><a class="header" href="#不同顺序锁定的互斥锁">不同顺序锁定的互斥锁</a></h3>
<p>下面是一个典型的死锁场景，死锁是按不同顺序进行锁定的。</p>
<p><img src="../../../images/detail/multithreading/10.png" alt="" /></p>
<p>线程1和线程2需要访问两个资源来完成它们的工作。当资源被两个单独的互斥体保护，并且以不同的顺序被请求(线程1:锁1，锁2;线程2:锁2，锁1)时，线程交错执行，线程1得到互斥锁1，然后线程2得到互斥锁2，从而程序进入停滞状态。每个线程都想获得另一个互斥锁，但需要另一个线程释放其需要的互斥锁。“死亡拥抱”这个形容，很好地描述了这种状态。</p>
<p>将这上图转换成代码。</p>
<pre><code class="language-c++">// deadlock.cpp

#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

struct CriticalData {
  std::mutex mut;
};

void deadLock(CriticalData&amp; a, CriticalData&amp; b) {

  a.mut.lock();
  std::cout &lt;&lt; &quot;get the first mutex&quot; &lt;&lt; std::endl;
  std::this_thread::sleep_for(std::chrono::microseconds(1));
  b.mut.lock();
  std::cout &lt;&lt; &quot;get the second mutext&quot; &lt;&lt; std::endl;
  // do something with a and b
  a.mut.unlock();
  b.mut.unlock();

}

int main() {

  CriticalData c1;
  CriticalData c2;

  std::thread t1([&amp;] {deadLock(c1, c2); });
  std::thread t2([&amp;] {deadLock(c2, c1); });

  t1.join();
  t2.join();

}
</code></pre>
<p>线程<code>t1</code>和<code>t2</code>调用死锁函数(第12 - 23行)，向函数传入了<code>c1</code>和<code>c2</code>(第27行和第28行)。由于需要保护<code>c1</code>和<code>c2</code>不受共享访问的影响，它们在内部各持有一个互斥量(为了保持本例简短，关键数据除了互斥量外没有其他函数或成员)。</p>
<p>第16行中，约1毫秒的短睡眠就足以产生死锁。</p>
<p><img src="../../../images/detail/multithreading/11.png" alt="" /></p>
<p>这时，只能按CTRL+C终止进程。</p>
<p>互斥量不能解决所有问题，但在很多情况下，锁可以帮助我们解决这些问题。</p>
<h3 id="锁"><a class="header" href="#锁">锁</a></h3>
<p>锁使用RAII方式处理它们的资源。锁在构造函数中自动绑定互斥量，并在析构函数中释放互斥量，这大大降低了死锁的风险。</p>
<p>锁有四种不同的形式：<code>std::lock_guard</code>用于简单程序，<code>std::unique_lock</code>用于高级程序。从C++14开始就可以用<code>std::shared_lock</code>来实现读写锁了。C++17中，添加了<code>std::scoped_lock</code>，它可以在原子操作中锁定更多的互斥对象。</p>
<p>首先，来看简单程序。</p>
<p><strong>std::lock_guard</strong></p>
<pre><code class="language-c++">std::mutex m;
m.lock();
sharedVariable = getVar();
m.unlock();
</code></pre>
<p>互斥量<code>m</code>可以确保对<code>sharedVariable = getVar()</code>的访问是有序的。有序指的是，每个线程按照某种顺序，依次访问临界区。代码很简单，但是容易出现死锁。如果临界区抛出异常或者忘记解锁互斥量，就会出现死锁。使用<code>std::lock_guard</code>，可以很优雅的解决问题：</p>
<pre><code class="language-c++">{
  std::mutex m,
  std::lock_guard&lt;std::mutex&gt; lockGuard(m);
  sharedVariable = getVar();
}
</code></pre>
<p>代码很简单，但是前后的花括号是什么呢？<code>std::lock_guard</code>的生存周期受其作用域的限制，作用域由<a href="http://en.cppreference.com/w/cpp/language/scope#Block_scope">花括号</a>构成。生命周期在达到右花括号时结束，<code>std::lock_guard</code>析构函数被调用，并且互斥量被释放。这都是自动发生的，如果<code>sharedVariable = getVar()</code>中的<code>getVar()</code>抛出异常，释放过程也会自动发生。函数作用域和循环作用域，也会限制实例对象的生命周期。</p>
<p><strong>std::scoped_lock</strong></p>
<p>C++17中，添加了<code>std::scoped_lock</code>。与<code>std::lock_guard</code>非常相似，但可以原子地锁定任意数量的互斥对象。</p>
<ol>
<li>如果<code>std::scoped_lock</code>调用一个互斥量，它的行为就类似于<code>std::lock_guard</code>，并锁定互斥量<code>m</code>: <code>m.lock</code>。如果<code>std::scoped_lock</code>被多个互斥对象调用<code>std::scoped_lock(mutextypes&amp;…)</code>，则使用<code>std::lock(m…)</code>函数进行锁定操作。</li>
<li>如果当前线程已经拥有了互斥量，但这个互斥量不可递归，那么这个行为就是未定义的，很有可能出现死锁。</li>
<li>只需要获得互斥量的所有权，而不需要锁定它们。这种情况下，必须将标志<code>std::adopt_lock_t</code>提供给构造函数：<code>std::scoped_lock(std::adopt_lock_t, mutextypes&amp;…m)</code>。</li>
</ol>
<p>使用<code>std::scoped_lock</code>，可以优雅地解决之前的死锁问题。下一节中，将讨论如何杜绝死锁。</p>
<p><strong>std::unique_lock</strong></p>
<p><code>std::unique_lock</code>比<code>std::lock_guard</code>更强大，也更重量级。</p>
<p>除了包含<code>std::lock_guard</code>提供的功能之外，<code>std::unique_lock</code>还允许：</p>
<ul>
<li>创建无需互斥量的锁</li>
<li>不锁定互斥量的情况下创建锁</li>
<li>显式地/重复地设置或释放关联的互斥锁量</li>
<li>递归锁定互斥量</li>
<li>移动互斥量</li>
<li>尝试锁定互斥量</li>
<li>延迟锁定关联的互斥量</li>
</ul>
<p>下表展示了<code>std::unique_lock lk</code>的成员函数：</p>
<table><thead><tr><th align="center">成员函数</th><th align="center">功能描述</th></tr></thead><tbody>
<tr><td align="center"><code>lk.lock()</code></td><td align="center">锁定相关互斥量</td></tr>
<tr><td align="center"><code>lk.try_lock()</code></td><td align="center">尝试锁定相关互斥量</td></tr>
<tr><td align="center"><code>lk.try_lock_for(relTime)</code></td><td align="center">尝试锁定相关互斥量</td></tr>
<tr><td align="center"><code>lk.try_lock_until(absTime)</code></td><td align="center">尝试锁定相关互斥量</td></tr>
<tr><td align="center"><code>lk.unlock()</code></td><td align="center">解锁相关互斥量</td></tr>
<tr><td align="center"><code>lk.release()</code></td><td align="center">释放互斥量，互斥量保持锁定状态</td></tr>
<tr><td align="center"><code>lk.swap(lk2)</code>和<code>std::swap(lk, lk2)</code></td><td align="center">交换锁</td></tr>
<tr><td align="center"><code>lk.mutex()</code></td><td align="center">返回指向相关互斥量的指针</td></tr>
<tr><td align="center"><code>lk.owns_lock()</code>和bool操作符</td><td align="center">检查锁<code>lk</code>是否有锁住的互斥量</td></tr>
</tbody></table>
<p><code>try_lock_for(relTime)</code>需要传入一个时间段，<code>try_lock_until(absTime)</code>需要传入一个绝对的时间点。<code>lk.try_lock_for(lk.try_lock_until)</code>会调用关联的互斥量<code>mut</code>的成员函数<code>mut.try_lock_for(mut.try_lock_until) </code>。相关的互斥量需要支持定时阻塞，这就需要使用稳定的时钟来限制时间。</p>
<p><code>lk.try_lock</code>尝试锁定互斥锁并立即返回。成功时返回true，否则返回false。相反，<code>lk.try_lock_for</code>和<code>lk.try_lock_until</code>则会让锁<code>lk</code>阻塞，直到超时或获得锁为止。如果没有关联的互斥锁，或者这个互斥锁已经被<code>std::unique_lock</code>锁定，那么<code>lk.try_lock</code>、<code>lk.try_lock_for</code>和<code>lk.try_lock_for</code>则抛出<code>std::system_error</code>异常。</p>
<p><code>lk.release()</code>返回互斥量，必须手动对其进行解锁。</p>
<p><code>std::unique_lock</code>在原子步骤中可以锁定多个互斥对象。因此，可以通过以不同的顺序锁定互斥量来避免死锁。还记得在互斥量中出现的死锁吗?</p>
<pre><code class="language-c++">// deadlock.cpp

#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

struct CriticalData {
  std::mutex mut;
};

void deadLock(CriticalData&amp; a, CriticalData&amp; b) {

  a.mut.lock();
  std::cout &lt;&lt; &quot;get the first mutex&quot; &lt;&lt; std::endl;
  std::this_thread::sleep_for(std::chrono::microseconds(1));
  b.mut.lock();
  std::cout &lt;&lt; &quot;get the second mutext&quot; &lt;&lt; std::endl;
  // do something with a and b
  a.mut.unlock();
  b.mut.unlock();

}

int main() {

  CriticalData c1;
  CriticalData c2;

  std::thread t1([&amp;] {deadLock(c1, c2); });
  std::thread t2([&amp;] {deadLock(c2, c1); });

  t1.join();
  t2.join();

}
</code></pre>
<p>让我们来解决死锁问题。死锁必须原子地锁定互斥对象，也正是下面的程序中所展示的。</p>
<pre><code class="language-c++">// deadlockResolved.cpp

#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

using namespace std;

struct CriticalData {
  mutex mut;
};

void deadLock(CriticalData&amp; a, CriticalData&amp; b) {

  unique_lock&lt;mutex&gt; guard1(a.mut, defer_lock);
  cout &lt;&lt; &quot;Thread: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; first mutex&quot; &lt;&lt; endl;

  this_thread::sleep_for(chrono::milliseconds(1));

  unique_lock&lt;mutex&gt; guard2(b.mut, defer_lock);
  cout &lt;&lt; &quot; Thread: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; second mutex&quot; &lt;&lt; endl;

  cout &lt;&lt; &quot;  Thread: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; get both mutex&quot; &lt;&lt; endl;
  lock(guard1, guard2);
  // do something with a and b
}

int main() {

  cout &lt;&lt; endl;

  CriticalData c1;
  CriticalData c2;

  thread t1([&amp;] {deadLock(c1, c2); });
  thread t2([&amp;] {deadLock(c2, c1); });

  t1.join();
  t2.join();

  cout &lt;&lt; endl;

}
</code></pre>
<p>如果使用<code>std::defer_lock</code>对<code>std::unique_lock</code>进行构造，则底层的互斥量不会自动锁定。此时(第16行和第21行)，<code>std::unique_lock</code>就是互斥量的所有者。由于<code>std::lock</code>是可变参数模板，锁操作可以原子的执行(第25行)。</p>
<blockquote>
<p><strong>使用std::lock进行原子锁定</strong></p>
<p><code>std::lock</code>可以在原子的锁定互斥对象。<code>std::lock</code>是一个可变参数模板，因此可以接受任意数量的参数。<code>std::lock</code>尝试使用避免死锁的算法，在一个原子步骤获得所有锁。互斥量会锁定一系列操作，比如：<code>lock</code>、<code>try_lock</code>和<code>unlock</code>。如果对锁或解锁的调用异常，则解锁操作会在异常重新抛出之前执行。</p>
</blockquote>
<p>本例中，<code>std::unique_lock</code>管理资源的生存期，<code>std::lock</code>锁定关联的互斥量，也可以反过来。第一步中锁住互斥量，第二步中<code>std::unique_lock</code>管理资源的生命周期。下面是第二种方法的例子：</p>
<pre><code class="language-c++">std::lock(a.mut, b.mut);
std::lock_guard&lt;std::mutex&gt; guard1(a.mut, std::adopt_lock);
std::lock_guard&lt;std::mutex&gt; guard2(b.mut, std::adopt_lock);
</code></pre>
<p>这两个方式都能解决死锁。</p>
<p><img src="../../../images/detail/multithreading/12.png" alt="" /></p>
<blockquote>
<p><strong>使用std::scoped_lock解决死锁</strong></p>
<p>C++17中解决死锁非常容易。有了<code>std::scoped_lock</code>帮助，可以原子地锁定任意数量的互斥。只需使用<code>std::scoped_lock</code>，就能解决所有问题。下面是修改后的死锁函数：</p>
<pre><code class="language-c++">// deadlockResolvedScopedLock.cpp
...
void deadLock(CriticalData&amp; a, CriticalData&amp; b) {
cout &lt;&lt; &quot;Thread: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; first mutex&quot; &lt;&lt; endl;
this_thread::sleep_for(chrono::milliseconds(1));
  cout &lt;&lt; &quot; Thread: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; second mutex&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot; Thread: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; get both mutex&quot; &lt;&lt; endl;
  
  std::scoped_lock(a.mut, b.mut);
// do something with a and b
  }
  
...
</code></pre>
</blockquote>
<p><strong>std::shared_lock</strong></p>
<p>C++14中添加了<code>std::shared_lock</code>。</p>
<p><code>std::shared_lock</code>与<code>std::unique_lock</code>的接口相同，但与<code>std::shared_timed_mutex</code>或<code>std::shared_mutex</code>一起使用时，行为会有所不同。许多线程可以共享一个<code>std::shared_timed_mutex (std::shared_mutex)</code>，从而实现读写锁。读写器锁的思想非常简单，而且非常有用。执行读操作的线程可以同时访问临界区，但是只允许一个线程写。</p>
<p>读写锁并不能解决最根本的问题——线程争着访问同一个关键区域。</p>
<p>电话本就是使用读写锁的典型例子。通常，许多人想要查询电话号码，但只有少数人想要更改。让我们看一个例子：</p>
<pre><code class="language-c++">// readerWriterLock.cpp

#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;shared_mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;

std::map&lt;std::string, int&gt; teleBook{ {&quot;Dijkstra&quot;, 1972}, {&quot;Scott&quot;, 1976},
                                                          {&quot;Ritchie&quot;, 1983} };

std::shared_timed_mutex teleBookMutex;

void addToTeleBook(const std::string&amp; na, int tele) {
  std::lock_guard&lt;std::shared_timed_mutex&gt; writerLock(teleBookMutex);
  std::cout &lt;&lt; &quot;\nSTARTING UPDATE &quot; &lt;&lt; na;
  std::this_thread::sleep_for(std::chrono::milliseconds(500));
  teleBook[na] = tele;
  std::cout &lt;&lt; &quot; ... ENDING UPDATE &quot; &lt;&lt; na &lt;&lt; std::endl;
}

void printNumber(const std::string&amp; na) {
  std::shared_lock&lt;std::shared_timed_mutex&gt; readerLock(teleBookMutex);
  std::cout &lt;&lt; na &lt;&lt; &quot;: &quot; &lt;&lt; teleBook[na];
}

int main() {

  std::cout &lt;&lt; std::endl;

  std::thread reader1([] {printNumber(&quot;Scott&quot;); });
  std::thread reader2([] {printNumber(&quot;Ritchie&quot;); });
  std::thread w1([] {addToTeleBook(&quot;Scott&quot;,1968); });
  std::thread reader3([] {printNumber(&quot;Dijkstra&quot;); });
  std::thread reader4([] {printNumber(&quot;Scott&quot;); });
  std::thread w2([] {addToTeleBook(&quot;Bjarne&quot;, 1965); });
  std::thread reader5([] {printNumber(&quot;Scott&quot;); });
  std::thread reader6([] {printNumber(&quot;Ritchie&quot;); });
  std::thread reader7([] {printNumber(&quot;Scott&quot;); });
  std::thread reader8([] {printNumber(&quot;Bjarne&quot;); });

  reader1.join();
  reader2.join();
  reader3.join();
  reader4.join();
  reader5.join();
  reader6.join();
  reader7.join();
  reader8.join();
  w1.join();
  w2.join();

  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; &quot;\nThe new telephone book&quot; &lt;&lt; std::endl;
  for (auto teleIt : teleBook) {
    std::cout &lt;&lt; teleIt.first &lt;&lt; &quot;: &quot; &lt;&lt; teleIt.second &lt;&lt; std::endl;
  }

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>第9行中的电话簿是共享变量，必须对其进行保护。八个线程要查询电话簿，两个线程想要修改它(第31 - 40行)。为了同时访问电话簿，读取线程使用<code>std::shared_lock&lt;std::shared_timed_mutex&gt;</code>(第23行)。写线程需要以独占的方式访问临界区，第15行中的<code>std::lock_guard&lt;std::shared_timed_mutex&gt;</code>具有独占性。最后，程序显示了更新后的电话簿(第55 - 58行)。</p>
<p><img src="../../../images/detail/multithreading/13.png" alt="" /></p>
<p>屏幕截图显示，读线程的输出是重叠的，而写线程是一个接一个地执行。这就意味着，读取操作应该是同时执行的。</p>
<p>这很容易让“电话簿”有未定义行为。</p>
<h3 id="未定义行为"><a class="header" href="#未定义行为">未定义行为</a></h3>
<p>程序有未定义行为。更准确地说，它有一个数据竞争。啊哈！？在继续之前，停下来想几秒钟。</p>
<p>数据竞争的特征是，至少有两个线程同时访问共享变量，并且其中至少有一个线程是写线程，这种情况很可能在程序执行时发生。使用索引操作符读取容器中的值，并可以修改它。如果元素在容器中不存在，就会发生这种情况。如果在电话簿中没有找到“Bjarne”，则从读访问中创建一对<code>(“Bjarne”，0)</code>。可以通过在第40行前面打印Bjarne的数据，强制数据竞争。</p>
<p>可以看到的是，Bjarne的值是0。</p>
<p><img src="../../../images/detail/multithreading/14.png" alt="" /></p>
<p>修复这个问题的最直接的方法是使用<code>printNumber</code>函数中的读取操作:</p>
<pre><code class="language-c++">// readerWriterLocksResolved.cpp

...

void printNumber(const std::string&amp; na){
  std::shared_lock&lt;std::shared_timed_mutex&gt; readerLock(teleBookMutex);
  auto searchEntry = teleBook.find(na);
  if(searchEntry != teleBook.end()){
    std::cout &lt;&lt; searchEntry-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; searchEntry-&gt;second &lt;&lt; std::endl;
  }
  else{
    std::cout &lt;&lt; na &lt;&lt; &quot; not found!&quot; &lt;&lt; std::endl;
  }
}
...
</code></pre>
<p>如果电话簿里没有相应键值，就把键值写下来，并且向控制台输出“找不到!”。</p>
<p><img src="../../../images/detail/multithreading/15.png" alt="" /></p>
<p>第二个程序执行的输出中，可以看到Bjarne的信息没有找到。第一个程序执行中，首先执行了<code>addToTeleBook</code>，所以Bjarne被找到了。</p>
<h3 id="线程安全的初始化"><a class="header" href="#线程安全的初始化">线程安全的初始化</a></h3>
<p>如果变量从未修改过，那么就不需要锁或原子变量来进行同步，只需确保以线程安全的方式初始化就可以了。</p>
<p>C++中有三种以线程安全初始化变量的方法：</p>
<ul>
<li>常量表达式</li>
<li><code>std::call_once</code>与<code>std::once_flag</code>结合的方式</li>
<li>作用域的静态变量</li>
</ul>
<blockquote>
<p><strong>主线程中的安全初始化</strong></p>
<p>以线程安全的方式初始化变量的最简单方法，是在创建任何子线程之前在主线程中初始化变量。</p>
</blockquote>
<p><strong>常数表达式</strong></p>
<p>常量表达式，是编译器可以在编译时计算的表达式，隐式线程安全的。将关键字<code>constexpr</code>放在变量前面，会使该变量成为常量表达式。常量表达式必须初始化。</p>
<pre><code class="language-c++">constexpr double pi = 3.14;
</code></pre>
<p>此外，用户定义的类型也可以是常量表达式。不过，必须满足一些条件才能在编译时初始化：</p>
<ul>
<li>不能有虚方法或虚基类</li>
<li>构造函数必须为空，且本身为常量表达式</li>
<li>必须初始化每个基类和每个非静态成员</li>
<li>成员函数在编译时应该是可调用的，必须是常量表达式</li>
</ul>
<p><code>MyDouble</code>的实例满足所有这些需求，因此可以在编译时实例化。所以，这个实例化是线程安全的。</p>
<pre><code class="language-c++">// constexpr.cpp

#include &lt;iostream&gt;

class MyDouble {
private:
  double myVal1;
  double myVal2;
public:
  constexpr MyDouble(double v1, double v2):myVal1(v1),myVal2(v2){}
  constexpr double getSum() const { return myVal1 + myVal2; }
};

int main() {

  constexpr double myStatVal = 2.0;
  constexpr MyDouble myStatic(10.5, myStatVal);
  constexpr double sumStat = myStatic.getSum();

}
</code></pre>
<p><strong>std::call_once和std::once_flag</strong></p>
<p>通过使用<code>std::call_once</code>函数，可以注册一个可调用单元。<code>std::once_flag</code>确保已注册的函数只调用一次。可以通过相同的<code>std::once_flag</code>注册其他函数，只能调用注册函数组中的一个函数。</p>
<p><code>std::call_once</code>遵循以下规则:</p>
<ul>
<li>只执行其中一个函数的一次，未定义选择哪个函数执行。所选函数与<code>std::call_once</code>在同一个线程中执行。</li>
<li>上述所选函数的执行成功完成之前，不返回任何调用。</li>
<li>如果函数异常退出，则将其传播到调用处。然后，执行另一个函数。</li>
</ul>
<p>这个短例演示了<code>std::call_once</code>和<code>std::once_flag</code>的应用(都在头文件<code>&lt;mutex&gt;</code>中声明)。</p>
<pre><code class="language-c++">// callOnce.cpp

#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

std::once_flag onceFlag;

void do_once() {
  std::call_once(onceFlag, [] {std::cout &lt;&lt; &quot;Only once.&quot; &lt;&lt; std::endl; });
}

void do_once2() {
  std::call_once(onceFlag, [] {std::cout &lt;&lt; &quot;Only once2.&quot; &lt;&lt; std::endl; });
}

int main() {
  
  std::cout &lt;&lt; std::endl;

  std::thread t1(do_once);
  std::thread t2(do_once);
  std::thread t3(do_once2);
  std::thread t4(do_once2);

  t1.join();
  t2.join();
  t3.join();
  t4.join();

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>程序从四个线程开始(第21 - 24行)。其中两个调用<code>do_once</code>，另两个调用<code>do_once2</code>。预期的结果是“Only once”或“Only once2”只显示一次。</p>
<p><img src="../../../images/detail/multithreading/16.png" alt="" /></p>
<p>单例模式保证只创建类的一个实例，这在多线程环境中是一个具有挑战性的任务。由于<code>std::call_once</code>和<code>std::once_flag</code>的存在，实现这样的功能就非常容易了。</p>
<p>现在，单例以线程安全的方式初始化。</p>
<pre><code class="language-c++">// singletonCallOnce.cpp

#include &lt;iostream&gt;
#include &lt;mutex&gt;

using namespace std;

class MySingleton {

private:
  static once_flag initInstanceFlag;
  static MySingleton* instance;
  MySingleton() = default;
  ~MySingleton() = default;

public:
  MySingleton(const MySingleton&amp;) = delete;
  MySingleton&amp; operator=(const MySingleton&amp;) = delete;

  static MySingleton* getInstance() {
    call_once(initInstanceFlag, MySingleton::initSingleton);
    return instance;
  }

  static void initSingleton() {
    instance = new MySingleton();
  }
};

MySingleton* MySingleton::instance = nullptr;
once_flag MySingleton::initInstanceFlag;

int main() {

  cout &lt;&lt; endl;

  cout &lt;&lt; &quot;MySingleton::getInstance(): &quot; &lt;&lt; MySingleton::getInstance() &lt;&lt; endl;
  cout &lt;&lt; &quot;MySingleton::getInstance(): &quot; &lt;&lt; MySingleton::getInstance() &lt;&lt; endl;

  cout &lt;&lt; endl;

}
</code></pre>
<p>静态变量<code>initInstanceFlag</code>在第11行声明，在第31行初始化。静态方法<code>getInstance</code>(第20 - 23行)使用<code>initInstanceFlag</code>标志，来确保静态方法<code>initSingleton</code>(第25 - 27行)只执行一次。</p>
<blockquote>
<p><strong>default和delete修饰符</strong></p>
<p>可以使用关键字<code>default</code>向编译器申请函数实现，编译器可以创建并实现它们。</p>
<p>用<code>delete</code>修饰一个成员函数的话，则该函数不可用，因此不能被调用。如果尝试使用它们，将得到一个编译时错误。这里有<a href="https://isocpp.org/wiki/faq/cpp11-language-classes">default和delete</a>的详细信息。</p>
</blockquote>
<p><code>MySingleton::getIstance() </code>函数显示了单例的地址。</p>
<p><img src="../../../images/detail/multithreading/17.png" alt="" /></p>
<h3 id="有作用域的静态变量"><a class="header" href="#有作用域的静态变量">有作用域的静态变量</a></h3>
<p>具有作用域的静态变量只创建一次，并且是惰性的，惰性意味着它们只在使用时创建。这一特点是基于Meyers单例的基础，以<a href="https://en.wikipedia.org/wiki/Scott_Meyers">Scott Meyers</a>命名，这是迄今为止C++中单例模式最优雅的实现。C++11中，带有作用域的静态变量有一个额外的特点，可以以线程安全的方式初始化。</p>
<p>下面是线程安全的Meyers单例模式。</p>
<pre><code class="language-c++">// meyersSingleton.cpp

class MySingleton {
public:
  static MySingleton&amp; getInstance() {
    static MySingleton instance;
    return instance;
  }

private:
  MySingleton();
  ~MySingleton();
  MySingleton(const MySingleton&amp;) = delete;
  MySingleton&amp; operator=(const MySingleton&amp;) = delete;
  
};

MySingleton::MySingleton()= default;
MySingleton::~MySingleton()= default;


int main(){
  
  MySingleton::getInstance();
  
}
</code></pre>
<blockquote>
<p><strong>编译器对静态变量的支持</strong></p>
<p>如果在并发环境中使用Meyers单例，请确保编译器对于C++11的支持。开发者经常依赖于C++11的静态变量语义，但是有时他们的编译器不支持这项特性，结果可能会创建多个单例实例。</p>
</blockquote>
<p>讨论了这么多，而在<code>thread_local</code>中就没有共享变量的问题了。</p>
<p>接下来，我们来了解一下<code>thread_local</code>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../../content/The-Details/Multithreading/2.1-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../../content/The-Details/Multithreading/2.3-chinese.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../../content/The-Details/Multithreading/2.1-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../../content/The-Details/Multithreading/2.3-chinese.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
