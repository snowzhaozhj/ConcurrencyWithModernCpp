<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>挑战 - ConcurrencyWithModernCpp</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../content/Reader-Testimonials.html"><strong aria-hidden="true">1.</strong> 读者推荐</a></li><li class="chapter-item expanded "><a href="../../content/Source-Code.html"><strong aria-hidden="true">2.</strong> 代码说明</a></li><li class="chapter-item expanded "><a href="../../content/How-you-should-read-the-book.html"><strong aria-hidden="true">3.</strong> 如何阅读</a></li><li class="chapter-item expanded "><a href="../../content/History-Quick-Overview.html"><strong aria-hidden="true">4.</strong> C++并发历史概述</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 详细介绍</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/The-Details/Memory-Model/1.0-chinese.html"><strong aria-hidden="true">5.1.</strong> 内存模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/The-Details/Memory-Model/1.1-chinese.html"><strong aria-hidden="true">5.1.1.</strong> 内存模型的基础知识</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Memory-Model/1.2-chinese.html"><strong aria-hidden="true">5.1.2.</strong> 编程协议</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Memory-Model/1.3-chinese.html"><strong aria-hidden="true">5.1.3.</strong> 原子操作</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Memory-Model/1.4-chinese.html"><strong aria-hidden="true">5.1.4.</strong> 同步和顺序</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Memory-Model/1.5-chinese.html"><strong aria-hidden="true">5.1.5.</strong> 栅栏(Fences)</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/The-Details/Multithreading/2.0-chinese.html"><strong aria-hidden="true">5.2.</strong> 多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/The-Details/Multithreading/2.1-chinese.html"><strong aria-hidden="true">5.2.1.</strong> 线程</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Multithreading/2.2-chinese.html"><strong aria-hidden="true">5.2.2.</strong> 共享数据</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Multithreading/2.3-chinese.html"><strong aria-hidden="true">5.2.3.</strong> 线程-本地数据</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Multithreading/2.4-chinese.html"><strong aria-hidden="true">5.2.4.</strong> 条件变量</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Multithreading/2.5-chinese.html"><strong aria-hidden="true">5.2.5.</strong> 任务</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.0-chinese.html"><strong aria-hidden="true">5.3.</strong> 标准库的并行算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.1-chinese.html"><strong aria-hidden="true">5.3.1.</strong> 执行策略</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.2-chinese.html"><strong aria-hidden="true">5.3.2.</strong> 算法</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.3-chinese.html"><strong aria-hidden="true">5.3.3.</strong> 新算法</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Parallel-Algorithms-of-the-Standard/3.4-chinese.html"><strong aria-hidden="true">5.3.4.</strong> 性能概况</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/The-Details/Case-Studies/4.0-chinese.html"><strong aria-hidden="true">5.4.</strong> 案例研究</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/The-Details/Case-Studies/4.1-chinese.html"><strong aria-hidden="true">5.4.1.</strong> 求向量元素的加和</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Case-Studies/4.2-chinese.html"><strong aria-hidden="true">5.4.2.</strong> 单例模式：线程安全的初始化</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Case-Studies/4.3-chinese.html"><strong aria-hidden="true">5.4.3.</strong> 使用CppMem进行优化</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/Case-Studies/4.4-chinese.html"><strong aria-hidden="true">5.4.4.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/The-Details/The-Future-CPP-20-23/5.0-chinese.html"><strong aria-hidden="true">5.5.</strong> C++20/23的特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/The-Details/The-Future-CPP-20-23/5.1-chinese.html"><strong aria-hidden="true">5.5.1.</strong> 关于执行</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/The-Future-CPP-20-23/5.2-chinese.html"><strong aria-hidden="true">5.5.2.</strong> 可协作中断的线程</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/The-Future-CPP-20-23/5.3-chinese.html"><strong aria-hidden="true">5.5.3.</strong> 原子智能指针</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/The-Future-CPP-20-23/5.4-chinese.html"><strong aria-hidden="true">5.5.4.</strong> 扩展特性</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/The-Future-CPP-20-23/5.5-chinese.html"><strong aria-hidden="true">5.5.5.</strong> 门闩和栅栏</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/The-Future-CPP-20-23/5.6-chinese.html"><strong aria-hidden="true">5.5.6.</strong> 协程</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/The-Future-CPP-20-23/5.7-chinese.html"><strong aria-hidden="true">5.5.7.</strong> 事务性内存</a></li><li class="chapter-item expanded "><a href="../../content/The-Details/The-Future-CPP-20-23/5.8-chinese.html"><strong aria-hidden="true">5.5.8.</strong> 任务块</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/Pattrns/Patterns-and-Best-Practices/6.0-chinese.html"><strong aria-hidden="true">6.1.</strong> 模式和最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/Pattrns/Patterns-and-Best-Practices/6.1-chinese.html"><strong aria-hidden="true">6.1.1.</strong> 相关历史</a></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Patterns-and-Best-Practices/6.2-chinese.html"><strong aria-hidden="true">6.1.2.</strong> 价值所在</a></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Patterns-and-Best-Practices/6.3-chinese.html"><strong aria-hidden="true">6.1.3.</strong> 模式与最佳实践</a></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Patterns-and-Best-Practices/6.4-chinese.html"><strong aria-hidden="true">6.1.4.</strong> 反模式</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Synchronisation-Patterns/7.0-chinese.html"><strong aria-hidden="true">6.2.</strong> 同步模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/Pattrns/Synchronisation-Patterns/7.1-chinese.html"><strong aria-hidden="true">6.2.1.</strong> 处理共享</a></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Synchronisation-Patterns/7.2-chinese.html"><strong aria-hidden="true">6.2.2.</strong> 处理突变</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Concurrent-Architecture/8.0-chinese.html"><strong aria-hidden="true">6.3.</strong> 并发架构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/Pattrns/Concurrent-Architecture/8.1-chinese.html"><strong aria-hidden="true">6.3.1.</strong> 活动对象</a></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Concurrent-Architecture/8.2-chinese.html"><strong aria-hidden="true">6.3.2.</strong> 监控对象</a></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Concurrent-Architecture/8.3-chinese.html"><strong aria-hidden="true">6.3.3.</strong> 半同步/半异步</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Best-Practices/9.0-chinese.html"><strong aria-hidden="true">6.4.</strong> 最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/Pattrns/Best-Practices/9.1-chinese.html"><strong aria-hidden="true">6.4.1.</strong> 通常情况</a></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Best-Practices/9.2-chinese.html"><strong aria-hidden="true">6.4.2.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="../../content/Pattrns/Best-Practices/9.3-chinese.html"><strong aria-hidden="true">6.4.3.</strong> 内存模型</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 数据结构</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/Data-Structures/10.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 有锁结构</a></li><li class="chapter-item expanded "><a href="../../content/Data-Structures/10.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 无锁结构</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 更多信息</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/Further-Information/11.1-chinese.html" class="active"><strong aria-hidden="true">8.1.</strong> 挑战</a></li><li class="chapter-item expanded "><a href="../../content/Further-Information/11.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 时间库</a></li><li class="chapter-item expanded "><a href="../../content/Further-Information/11.3-chinese.html"><strong aria-hidden="true">8.3.</strong> CppMem-概述</a></li><li class="chapter-item expanded "><a href="../../content/Further-Information/11.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 术语表</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">ConcurrencyWithModernCpp</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="挑战"><a class="header" href="#挑战">挑战</a></h1>
<p>编写并发程序本身就很复杂，即便是使用C++11和C++14的新特性，也是如此。我希望通过用一整章的内容来讨论并发编程的挑战，读者们会更清楚其中的陷阱与挑战。</p>
<h2 id="aba问题"><a class="header" href="#aba问题">ABA问题</a></h2>
<p>ABA表示读取了一个值两次，每次都返回A值。因此，可以得出这样的结论：两次读取之间，相应的变量没有任何变化。然而，在两次读取之间，变量可能有被更新为B的时刻。</p>
<p>用一个简单的场景来比拟这个问题。</p>
<p><strong>一个例子</strong></p>
<p>这个场景里，你坐在车里等待交通灯变绿，绿色代表B，红色代表A。接下来会发生了什么?</p>
<ol>
<li>你看到交通灯，它是红色的(A)。</li>
<li>因为很无聊，你打开手机看新闻，而忘记了时间。</li>
<li>当你再看一次交通灯时。该死！还是红色(A)。</li>
</ol>
<p>当然，交通灯在你两次抬头看之间已经变成绿灯过。对于线程(进程)来说，意味着什么?</p>
<ol>
<li>线程1读取值为A的变量<code>var</code>。</li>
<li>线程1被抢占，线程2运行。</li>
<li>线程2将变量<code>var</code>从A更改为B，再更改为A。</li>
<li>线程1继续运行并检查变量<code>var</code>的值并得到A。因为获取到值A，线程1继续运行。</li>
</ol>
<p>通常这不是一个问题，可以忽略。</p>
<p><strong>非关键的ABA</strong></p>
<pre><code class="language-c++">// fetch_mult.cpp

#include &lt;atomic&gt;
#include &lt;iostream&gt;

template &lt;typename T&gt;
T fetch_mult(std::atomic&lt;T&gt;&amp; shared, T mult) {
  T oldValue = shared.load();
  while (!shared.compare_exchange_strong(oldValue, oldValue * mult));
  return oldValue;
}

int main() {
  std::atomic&lt;int&gt; myInt{ 5 };
  std::cout &lt;&lt; myInt &lt;&lt; std::endl;
  fetch_mult(myInt, 5);
  std::cout &lt;&lt; myInt &lt;&lt; std::endl;
}
</code></pre>
<p><code>compare_exchange_strong</code>和<code>compare_exchange_weak</code>可以在<code>fetch_mult</code>(第6行)中观察到的ABA问题。<code>fetch_mult</code>将<code>std::atomic&lt;t&gt;&amp; shared</code>和<code>mult</code>相乘。</p>
<p>关键是，读取旧值<code>T oldValue = shared.load()</code>第8行和第9行中的新值比较之间有一个小的时间窗口。因此，另一个线程可以介入，将<code>oldValue</code>从更改为另一个值，然后再返回<code>oldValue</code>。旧值是A，另一个线程修改的值是ABA中的B。</p>
<p>通常，当读操作处理相同的、未更改的变量，则没有什么影响。但是，在无锁并发的数据结构中，ABA可能会产生重大影响。</p>
<p><strong>无锁数据结构</strong></p>
<p>这里不会详细介绍无锁数据结构，仅用单链表实现的无锁堆栈，堆栈只支持两个操作：</p>
<ol>
<li>pop：弹出顶部对象，并返回指向它的指针。</li>
<li>push：将指定的对象推入堆栈。</li>
</ol>
<p>这里使用伪代码描述pop操作，以便了解ABA问题。pop操作执行以下步骤：</p>
<ol>
<li>获取头节点:head</li>
<li>获取后续节点:headNext</li>
<li>如果head仍然是堆栈的头节点，则将headNext作为新的头结点。</li>
</ol>
<p>下面是堆栈的前两个节点:</p>
<p><code>Stack: TOP -&gt; head -&gt; headNext -&gt; ...</code></p>
<p>现在，来构造ABA问题的情景。</p>
<p><strong>构造ABA</strong></p>
<p>我们从下面的堆栈开始:</p>
<p><code>Stack: TOP -&gt; A -&gt; B -&gt; C</code></p>
<p>线程1处于活动状态，希望弹出堆栈的头节点。</p>
<ul>
<li>
<p>Thread 1操作时</p>
<p>head = A</p>
<p>headNext = B</p>
</li>
</ul>
<p>线程1完成pop前，线程2开始工作。</p>
<ul>
<li>
<p>Thread 2 pop A</p>
<p><code>Stack: TOP -&gt; B -&gt; C</code></p>
</li>
<li>
<p>Thread 2 pop B 并且删除B</p>
<p><code>Stack: TOP -&gt; C</code></p>
</li>
<li>
<p>Thread 2把A推回去</p>
<p><code>Stack: TOP -&gt; A -&gt; C</code></p>
</li>
</ul>
<p>线程1重新调度，并检查<code>A == head</code>，因为当前<code>A == head</code>，那么<code>headNext</code>应该是B，但B已经被删除了。因此，程序具有未定义行为。</p>
<p>用什么来拯救ABA问题呢？接下来就介绍，ABA问题的一些补救措施。</p>
<p><strong>补救措施</strong></p>
<p>ABA的概念问题很容易理解，解决方案是消除节点过早的删除。以下是一些补救措施：</p>
<p><strong>标记参考状态</strong></p>
<p>可以使用地址的低位向每个节点添加标记，以表示节点成功修改的频率。尽管检查返回true，但比较-交换(CAS)会失败。这个想法并不能解决问题，因为标记位可能最终会交换。</p>
<p>引用标记状态通常用于事务内存中。</p>
<p>接下来的三种技术是基于延迟回收的思想。</p>
<p><strong>垃圾收集</strong></p>
<p>垃圾收集只保证在不再需要时删除变量。这听起来很有希望解决ABA问题，但有一个明显的缺点。大多数垃圾收集器不是无锁的，即使有一个无锁的数据结构，整个系统也不是无锁的。</p>
<p><strong>风险指针</strong></p>
<p>维基页面： <a href="https://en.wikipedia.org/wiki/Hazard_pointer">Hazard Pointers</a></p>
<p>风险指针系统中，每个线程都保存一个风险指针列表，指示线程当前正在访问哪些节点(许多系统中，这个“列表”可能仅限于一两个元素)。风险指针列表中的节点不能被任何其他线程修改或释放。当一个线程想要删除一个节点时，它会将其放在一个节点列表中，进行“稍后释放”，直到没有其他线程的危险列表包含该指针时，才释放该节点的内存。一个专门的垃圾收集线程可以手工进行垃圾收集(如果“稍后释放”的列表由所有线程共享)；或者，清理“被释放”列表可以由每个工作线程，作为“pop”等操作的一部分。</p>
<p><strong>RCU 读取-复制-更新</strong></p>
<p>RCU是Read Copy Update的缩写，是一种用于只读数据结构的同步技术。RCU是由Paul McKenney创建的，自2002年以来一直在Linux内核中使用。</p>
<p>思想很简单，就跟缩写一样，要修改数据，要复制数据。反之，所有的读取都使用原始数据。如果没有读取操作，那么可以安全地将数据进行修改。</p>
<p>要了解更多关于RCU的细节，请阅读Paul McKenney的这篇文章:<a href="https://lwn.net/Articles/262464/">What is RCU, Fundamentally?</a> </p>
<blockquote>
<p>两个新的提案</p>
<p>作为并发工具包的一部分，有两个关于未来C++标准的提案。关于风险指针的提案是<a href="http://www.modernescpp.com/open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0233r0.pdf">P0233R0</a>，关于RCU的提案是<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0461r0.pdf">P0461R0</a> 。</p>
</blockquote>
<h2 id="阻塞问题"><a class="header" href="#阻塞问题">阻塞问题</a></h2>
<p>为了说明我的观点，需要将条件变量与谓词结合。不这样做的话，程序可能会出现伪唤醒或未唤醒的情况。</p>
<p>如果使用没有谓词的条件变量，则通知线程可能在等待线程等待之前发送通知，等待线程将永远等待，这种现象被称为“未唤醒“。</p>
<p>程序如下。</p>
<pre><code class="language-c++">// conditionVariableBlock.cpp

#include &lt;iostream&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex mutex_;
std::condition_variable condVar;

bool dataReady;


void waitingForWork() {

  std::cout &lt;&lt; &quot;Worker: Waiting for work.&quot; &lt;&lt; std::endl;

  std::unique_lock&lt;std::mutex&gt; lck(mutex_);
  condVar.wait(lck);
  // do the work
  std::cout &lt;&lt; &quot;Work done.&quot; &lt;&lt; std::endl;

}

void setDataReady() {

  std::cout &lt;&lt; &quot;Sender: Data is ready.&quot; &lt;&lt; std::endl;
  condVar.notify_one();

}

int main() {

  std::cout &lt;&lt; std::endl;

  std::thread t1(setDataReady);
  std::thread t2(waitingForWork);

  t1.join();
  t2.join();

  std::cout &lt;&lt; std::endl;
}
</code></pre>
<p>程序的第一次工作得很好，第二次锁定的原因是<code>notify</code>(第28行)发生在线程<code>t2</code>(第37行)等待之前(第19行)。</p>
<p><img src="../../images/Further-Information/Challenges/1.png" alt="" /></p>
<p>当然，死锁和活锁是条件竞争的副产物。死锁通常取决于线程的交错，有时会发生，有时不会。活锁与死锁类似，当死锁阻塞时，活锁“似乎''没有阻塞程序。</p>
<h2 id="破坏程序的不变量"><a class="header" href="#破坏程序的不变量">破坏程序的不变量</a></h2>
<p>程序不变量，应该在程序的整个生命周期中”保持不变“。</p>
<p>恶性条件竞争破坏程序的不变量。下面程序的不变量是所有余额的总和，例子中是200欧元，因为每个账户起步都是100欧元(第9行)。</p>
<pre><code class="language-c++">// breakingInvariant.cpp

#include &lt;atomic&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

struct Account {
  std::atomic&lt;int&gt; balance{ 100 };
};

void transferMoney(int amount, Account&amp; from, Account&amp; to) {
  using namespace std::chrono_literals;
  if (from.balance &gt;= amount) {
    from.balance -= amount;
    std::this_thread::sleep_for(1ns);
    to.balance += amount;
  }
}

void printSum(Account&amp; a1, Account&amp; a2) {
  std::cout &lt;&lt; (a1.balance + a2.balance) &lt;&lt; std::endl;
}

int main() {

  std::cout &lt;&lt; std::endl;

  Account acc1;
  Account acc2;

  std::cout &lt;&lt; &quot;Initial sum: &quot;;
  printSum(acc1, acc2);

  std::thread thr1(transferMoney, 5, std::ref(acc1), std::ref(acc2));
  std::thread thr2(transferMoney, 13, std::ref(acc2), std::ref(acc1));
  std::cout &lt;&lt; &quot;Intermediate sum: &quot;;
  std::thread thr3(printSum, std::ref(acc1), std::ref(acc2));

  thr1.join();
  thr2.join();
  thr3.join();

  std::cout &lt;&lt; &quot;  acc1.balance: &quot; &lt;&lt; acc1.balance &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;  acc2.balance: &quot; &lt;&lt; acc2.balance &lt;&lt; std::endl;

  std::cout &lt;&lt; &quot;Final sum: &quot;;
  printSum(acc1, acc2);

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>开始时，账户的总数是200欧元。第33行，通过使用第21 - 23行中的<code>printSum</code>函数来显示金额和。第38行使不变量可见。因为第16行有<code>1ns</code>的短睡眠，所以中间的金额是182欧元。最后，每个账户的余额都是正确的(第44行和第45行)，金额是200欧元(第48行)。</p>
<p>下面是程序的输出。</p>
<p><img src="../../images/Further-Information/Challenges/2.png" alt="" /></p>
<h2 id="数据竞争"><a class="header" href="#数据竞争">数据竞争</a></h2>
<p>数据竞争是指至少两个线程同时访问一个共享变量的情况，并且至少有一个线程尝试修改该变量。</p>
<p>程序有数据竞争，则会出现未定义行为，结果是不可预期的。</p>
<p>来看一个数据竞争的程序。</p>
<pre><code class="language-c++">// addMoney.cpp

#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

struct Account {
  int balance{ 100 };
};

void addMoney(Account&amp; to, int amount) {
    to.balance += amount;
}

int main() {

  std::cout &lt;&lt; std::endl;

  Account account;

  std::vector&lt;std::thread&gt; vecThreads(100);


  for (auto&amp; thr : vecThreads) thr = std::thread(addMoney, std::ref(account), 50);

  for (auto&amp; thr : vecThreads) thr.join();


  std::cout &lt;&lt; &quot;account.balance: &quot; &lt;&lt; account.balance &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</code></pre>
<p>100个线程<code>addMoney</code>函数将向相同的帐户(第20行)添加50欧元(第25行)。关键的，对账户的写入是不同步的，这里有一个数据竞争，因为是未定义行为，所以结果无效。最后的余额(第30行)会在5000欧元和5100欧元之间。</p>
<p><img src="../../images/Further-Information/Challenges/3.png" alt="" /></p>
<h2 id="死锁"><a class="header" href="#死锁">死锁</a></h2>
<p>死锁是一种状态，因为要等待没有得到的资源的释放，所以至少有一个线程会永久阻塞。</p>
<p>造成死锁的主要原因有两个:</p>
<ol>
<li>互斥锁未解锁。</li>
<li>以不同的顺序锁定互斥锁。</li>
</ol>
<p>为了避免第二个问题，在经典C++中使用了诸如<a href="http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2008/0801/071201hs01/071201hs01.html">层次锁</a>之类的技术。</p>
<p>有关死锁，以及如何用现代C++克服死锁的详细信息，请参阅互斥量和锁的章节内容。</p>
<blockquote>
<p><strong>多次锁定非递归互斥锁</strong></p>
<p>多次锁定非递归互斥锁会导致未定义行为。</p>
<pre><code class="language-c++">// lockTwice.cpp

#include &lt;iostream&gt;
#include &lt;mutex&gt;

int main() {

    std::mutex mut;

    std::cout &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;first lock call&quot; &lt;&lt; std::endl;

    mut.lock();

    std::cout &lt;&lt; &quot;second lock call&quot; &lt;&lt; std::endl;

    mut.lock();

    std::cout &lt;&lt; &quot;third lock call&quot; &lt;&lt; std::endl;
}
</code></pre>
<p>通常会死锁。</p>
<p><img src="../../images/Further-Information/Challenges/4.png" alt="" /></p>
</blockquote>
<h2 id="伪共享"><a class="header" href="#伪共享">伪共享</a></h2>
<p>当处理器从主存中读取一个变量(如int)时，从内存中读取的数据要大于int的大小。处理器会从缓存中读取整个高速缓存行(通常为64字节)。</p>
<p>如果两个线程，同时读取位于同一高速缓存行上的不同变量a和b，则会发生伪共享。虽然a和b在逻辑上是分开的，但在物理地址上是相连的。由于a和b共享同一条高速缓存线行，因此有必要在高速缓存行上进行硬件同步。得到了正确的结果，但是并发的性能下降了。正是这种现象发生在下面的程序中：</p>
<pre><code class="language-c++">// falseSharing.cpp

#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

constexpr long long size{ 100'000'000 };

struct Sum {
  long long a{ 0 };
  long long b{ 0 };
};

int main() {

  std::cout &lt;&lt; std::endl;

  Sum sum;

  std::cout &lt;&lt; &amp;sum.a &lt;&lt; std::endl;
  std::cout &lt;&lt; &amp;sum.b &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

  std::vector&lt;int&gt; randValues, randValues2;
  randValues.reserve(size);
  randValues2.reserve(size);

  std::mt19937 engine;
  std::uniform_int_distribution&lt;&gt; uniformDist(1, 10);

  int randValue;
  for (long long i = 0; i &lt; size; ++i) {
    randValue = uniformDist(engine);
    randValues.push_back(randValue);
    randValues2.push_back(randValue);
  }

  auto sta = std::chrono::steady_clock::now();

  std::thread t1([&amp;sum, &amp;randValues] {
    for (auto val : randValues) sum.a += val;
    });

  std::thread t2([&amp;sum, &amp;randValues2] {
    for (auto val : randValues2)sum.b += val;
    });

  t1.join(), t2.join();

  std::chrono::duration&lt;double&gt; dur = std::chrono::steady_clock::now() - sta;
  std::cout &lt;&lt; &quot;Time for addition &quot; &lt;&lt; dur.count()
    &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;

  std::cout &lt;&lt; &quot;sum.a: &quot; &lt;&lt; sum.a &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;sum.b: &quot; &lt;&lt; sum.b &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;
  
}
</code></pre>
<p>第13行和第14行中的变量<code>a</code>和<code>b</code>共享同个缓存行。线程<code>t1(</code>第44行)和线程<code>t2</code>同时使用两个变量，对向量<code>randValues</code>和<code>randValues2</code>中的元素进行求和。两个向量在1到10之间都有1亿个整数。程序的输出显示了一些有趣的事情，<code>a</code>和<code>b</code>在8字节边界上对齐，因为我的操作系统中的<code>long long int</code>是8字节对齐的。</p>
<p><img src="../../images/Further-Information/Challenges/5.png" alt="" /></p>
<p>如果将<code>a</code>和<code>b</code>的对齐方式改为64字节会发生什么?64字节是我系统上的高速缓存行的大小。我要对结构做点小改动，这次不用种子来生成随机数，所以每次都得到的随机数相同。</p>
<pre><code class="language-c++">struct Sum{
  alignas(64) long long a{0};
  alignas(64) long long b{0};
};
</code></pre>
<p><img src="../../images/Further-Information/Challenges/6.png" alt="" /></p>
<p>现在，<code>a</code>和<code>b</code>在64字节边界处对齐，程序速度提高了6倍多。原因是<code>a</code>和<code>b</code>现在不在同一高速缓存行上。</p>
<blockquote>
<p><strong>用优化器检测伪共享</strong></p>
<p>如果我用最大的优化选项编译的程序，优化器会检测到伪共享并消除它。这意味着，我得到了相同的性能数据与真共享，这也适用于Windows。以下是优化后的性能数字。</p>
<p><img src="../../images/Further-Information/Challenges/7.png" alt="" /></p>
</blockquote>
<blockquote>
<p><strong>C++17中的<code>std:: hardware_destructive_interference_size</code>和与<code>std:: hardware_constructive_interference_size</code></strong></p>
<p><code>std::hardware_destructive_interference_size</code>和<code>std::hardware_constructive_interference_size</code>允许以一种可移植的方式处理高速缓存行的大小。<code>std::hardware_destructive_interference_size</code>返回两个对象之间的最小偏移量，以避免伪共享；<code>std::hardware_constructive_interference_size</code>返回相邻内存的最大大小，以满足真共享。</p>
<p>在C++17中，Sum可以以一种平台无关的方式编写。</p>
<pre><code class="language-c++">struct Sum{
 alignas(std::hardware_destructive_interference_size) long long a{0};
 alignas(std::hardware_destructive_interference_size) long long b{0};
};
</code></pre>
</blockquote>
<h2 id="变量的生命周期问题"><a class="header" href="#变量的生命周期问题">变量的生命周期问题</a></h2>
<p>写一个具有生命周期相关问题的C++示例非常容易。让创建的线程<code>t</code>在后台运行(也就是说，它通过调用<code>t.detach()</code>来分离)，并且让它只完成一半的工作。这里，创建者线程不会等待子线程完成。在这种情况下，必须非常小心，最好不要在子线程中使用属于创建线程的任何东西。</p>
<pre><code class="language-c++">// lifetimeIssues.cpp

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;

int main() {

  std::cout &lt;&lt; &quot;Begin: &quot; &lt;&lt; std::endl;

  std::string mess{ &quot;Child thread&quot; };

  std::thread t([&amp;mess] {std::cout &lt;&lt; mess &lt;&lt; std::endl; });
  t.detach();

  std::cout &lt;&lt; &quot;End:&quot; &lt;&lt; std::endl;

}
</code></pre>
<p>这程序太简单了。线程<code>t</code>使用<code>std::cout</code>和变量<code>mess</code>，它们都属于主线程。结果是，在第二次运行时，我看不到子线程的输出。只有“Begin:”(第9行)和“End:”(第16行)打印了出来。</p>
<p><img src="../../images/Further-Information/Challenges/8.png" alt="" /></p>
<h2 id="移动线程"><a class="header" href="#移动线程">移动线程</a></h2>
<p>移动线程会使线程的生命周期问题变得更加复杂。</p>
<p>线程支持移动语义，但不支持复制语义。原因是<code>std::thread</code>的复制构造函数被设置为<code>delete</code>：<code>thread (const thread&amp;) = delete;</code>。试想，如果线程在持有锁的情况下能进行复制，会发生什么。</p>
<p>让我们移动一个线程。</p>
<p>错误地移动线程</p>
<pre><code class="language-c++">// threadMoved.cpp

#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;

int main(){
  
  std::thread t([]{std::cout &lt;&lt; std::this_thread::get_id();});
  std::thread t2([]{std::cout &lt;&lt; std::this_thread::get_id();});
  
  t = std::move(t2);
  t.join();
  t2.join();
}
</code></pre>
<p>线程<code>t</code>和<code>t2</code>应该完成它们的工作：打印它们的id。除此之外，线程<code>t2</code>的所有权移动到<code>t</code>(第12行)。最后，主线程处理它的子线程并汇入它们。等一下，结果与我的预期大不相同:</p>
<p><img src="../../images/Further-Information/Challenges/9.png" alt="" /></p>
<p>出了什么问题?这里有两个问题:</p>
<ol>
<li>通过移动线程<code>t2</code>, <code>t</code>获得一个新的可调用单元，并调用它的析构函数。结果，<code>t</code>的析构函数调用<code>std::terminate</code>，原始的<code>t</code>线程仍然是可汇入的。</li>
<li>线程<code>t2</code>没有相关的可调用单元，在没有可调用单元的线程上调用<code>join</code>会导致异常<code>std::system_error</code>。</li>
</ol>
<p>了解了这一点，修复工作就很简单了。</p>
<pre><code class="language-c++">// threadMovedFixed.cpp

#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;

int main(){
  
  std::thread t([]{std::cout &lt;&lt; std::this_thread::get_id();});
  std::thread t2([]{std::cout &lt;&lt; std::this_thread::get_id();});
  
  t.join();
  t = std::move(t2);
  t2.join();
  
  std::cout &lt;&lt; &quot;\n&quot;;
  std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;t2.joinable(): &quot; &lt;&lt; t2.joinable() &lt;&lt; std::endl;
  
}
</code></pre>
<p>结果是线程<code>t2</code>不可汇入。</p>
<p><img src="../../images/Further-Information/Challenges/10.png" alt="" /></p>
<h2 id="竞态条件"><a class="header" href="#竞态条件">竞态条件</a></h2>
<p>竞态条件是一种情况，其中操作的结果取决于某些操作的交错。</p>
<p>竞态条件很难发现。由于其取决于线程是否交错出现，也就是内核的数量、系统的利用率或可执行文件的优化级别，都可能是导致出现竞态条件的原因。</p>
<p>竞态条件本身并没什么。但线程以不同的方式交织在一起后，常常会导致严重的问题。这种情况下，称其为<strong>恶性竞争条件</strong>。恶意竞争条件的典型症状表现：数据竞争、破坏程序不变量、阻塞线程，或变量有生存周期问题等。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../content/Data-Structures/10.2-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../content/Further-Information/11.2-chinese.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../content/Data-Structures/10.2-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../content/Further-Information/11.2-chinese.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
